# Anthropic Content Protocol

This document captures insights about how Claude Code (and Anthropic's API) structures its communication protocol.

## Architecture Overview

The protocol uses multiple layers with different formats:

1. **SSE (Server-Sent Events)** - Transport layer for streaming over HTTP
2. **JSON** - Event format describing the response stream structure
3. **XML** - Tool calling format for function invocations

## Why Multiple Formats?

### SSE: Transport Layer
Server-Sent Events allow the API to push updates to the client over a single HTTP connection. This enables streaming responses where Claude's output appears incrementally rather than all at once.

### JSON: API Protocol Layer
Each SSE event contains JSON data that describes what's happening in the response stream. Example structure:

```
data: {"type": "content_block_start", "content_block": {"type": "text"}}
data: {"type": "content_block_delta", "delta": {"text": "Let me "}}
data: {"type": "content_block_delta", "delta": {"text": "read that file..."}}
data: {"type": "content_block_stop"}

data: {"type": "content_block_start", "content_block": {"type": "tool_use", "name": "Read"}}
data: {"type": "content_block_delta", "delta": {"parameter_name": "file_path"}}
data: {"type": "content_block_delta", "delta": {"parameter_value": "/path/to/file"}}
data: {"type": "content_block_stop"}
```

The JSON layer is controlled by Anthropic's server infrastructure and describes the structure of the response stream.

### XML: Tool Invocation Content
When Claude invokes tools, it generates XML as the actual content. Example:

```xml
<antml:function_calls>
  <antml:invoke name="Read">
    <antml:parameter name="file_path">/path/to/file.txt</antml:parameter>
  </antml:invoke>
</antml:function_calls>
```

The XML is generated by the model (Claude) as part of its output tokens, not by the API framework.

## Content Blocks

A single response from Claude can contain multiple content blocks:

- **Text blocks** - Regular markdown text (explanations, answers, etc.)
- **Tool use blocks** - XML function calls

These blocks are streamed as part of the same message. For example:

1. Text block: "Let me search for that information..."
2. Tool use block: `<invoke name="Grep">...</invoke>`
3. Text block: "Here's what I found..."

## Why XML for Tool Calls?

Using different formats for different layers creates clear separation:

### 1. Clear Boundaries
- **JSON**: API protocol (controlled by Anthropic's server)
- **XML**: Model-generated content (produced by Claude)

This makes it immediately obvious which layer you're looking at.

### 2. Who Generates What
- The JSON structure is generated by the API framework
- The XML is generated by the model as part of its output tokens

### 3. Parsing Clarity
The client doesn't have to worry about nested JSON (JSON inside JSON). When it sees a `tool_use` content block, it knows the content will be XML, not more JSON that could be confused with the protocol layer.

### 4. Escaping Simplicity
If tool calls were JSON, you'd need to escape JSON within JSON. With XML content in JSON events, there's no ambiguity or complex escaping needed.

### 5. Text Handling
XML naturally handles multi-line text content between tags without needing escape sequences (like `\n` in JSON strings). This is useful when parameters contain long prompts or code snippets.

## Parallel Tool Calls

Claude can invoke multiple tools in a single response by including multiple tool use blocks:

```xml
<antml:function_calls>
  <antml:invoke name="Read">
    <antml:parameter name="file_path">/path/to/file1.txt</antml:parameter>
  </antml:invoke>
  <antml:invoke name="Read">
    <antml:parameter name="file_path">/path/to/file2.txt</antml:parameter>
  </antml:invoke>
  <antml:invoke name="Read">
    <antml:parameter name="file_path">/path/to/file3.txt</antml:parameter>
  </antml:invoke>
</antml:function_calls>
```

All three reads happen in parallel, maximizing performance when there are no dependencies between operations.

## Summary

The multi-format approach creates a clean separation of concerns:
- SSE handles the streaming transport
- JSON describes the protocol structure
- XML represents the model's tool invocations

This layered architecture provides clarity, avoids escaping complexity, and makes it easy to distinguish between protocol metadata and model-generated content.

---

## Comparison: Anthropic vs OpenAI Streaming Protocols

While both Anthropic and OpenAI use Server-Sent Events (SSE) for streaming, they differ significantly in how they structure tool calls.

### OpenAI's Approach: JSON Throughout

OpenAI uses **JSON for everything** - both the protocol layer and tool calls:

**Format Example:**
```
data: {"id":"chatcmpl-...","object":"chat.completion.chunk","choices":[{"index":0,"delta":{"content":"Hello"},"finish_reason":null}]}

data: {"id":"chatcmpl-...","object":"chat.completion.chunk","choices":[{"index":0,"delta":{"tool_calls":[{"index":0,"function":{"name":"get_weather","arguments":"{\"city\""}}]},"finish_reason":null}]}

data: [DONE]
```

**Tool Call Structure (JSON):**
```json
{
  "delta": {
    "tool_calls": [{
      "index": 0,
      "function": {
        "name": "get_weather",
        "arguments": "{\"city\":\"San Francisco\"}"
      }
    }]
  }
}
```

**Characteristics:**
- Tool calls are JSON objects within the delta
- Tool arguments are JSON strings that build up incrementally across chunks
- Requires escaping JSON within JSON
- Stream terminates with `data: [DONE]`

### Anthropic's Approach: XML for Tool Calls

Anthropic uses **JSON for protocol, XML for tool calls**:

**Tool Call Structure (XML):**
```xml
<antml:function_calls>
  <antml:invoke name="Read">
    <antml:parameter name="file_path">/path/to/file.txt</antml:parameter>
  </antml:invoke>
</antml:function_calls>
```

**Characteristics:**
- Tool calls are XML generated by the model
- Clear separation between JSON protocol and XML content
- No JSON escaping issues
- Multi-line text handling is simpler (no `\n` escaping needed)
- Format difference creates visual distinction between layers

### Key Differences Summary

| Aspect | OpenAI | Anthropic |
|--------|---------|-----------|
| **Transport** | SSE | SSE |
| **Protocol Format** | JSON | JSON |
| **Tool Call Format** | JSON | XML |
| **Nesting** | JSON in JSON | XML in JSON |
| **Escaping** | Required (JSON in JSON) | Minimal (XML in JSON) |
| **Stream End** | `data: [DONE]` | Content block stop events |
| **Multi-line Text** | Requires `\n` escaping | Natural in XML tags |
| **Layer Separation** | Same format throughout | Different formats for different layers |

### Implementation Considerations for Ikigai

When adding tool use to this project, consider:

1. **API Choice**: The project currently uses OpenAI's API, which means tool calls will be JSON-formatted
2. **Parsing**: OpenAI's approach requires handling JSON within JSON, with proper escaping
3. **Incremental Streaming**: Tool arguments arrive incrementally and must be accumulated across chunks
4. **Finish Reasons**: Watch for `finish_reason: "tool_calls"` to know when tool execution is needed

### References

**OpenAI Streaming Documentation:**
- [OpenAI Platform: Streaming API responses](https://platform.openai.com/docs/guides/streaming-responses)
- [Understanding OpenAI's New Responses API Streaming Model](https://madhub081011.medium.com/understanding-openais-new-responses-api-streaming-model-a6d932e481e8)
- [Stream OpenAI responses using Server Sent Events - OpenFaaS](https://www.openfaas.com/blog/openai-streaming-responses/)
- [AI SDK Core: streamText](https://ai-sdk.dev/docs/reference/ai-sdk-core/stream-text)
- [OpenAI Agents SDK: Streaming](https://openai.github.io/openai-agents-python/streaming/)

**Anthropic Documentation:**
- [Anthropic Messages API Documentation](https://docs.anthropic.com/en/api/messages)
- [Tool Use (Function Calling)](https://docs.anthropic.com/en/docs/tool-use)

# Task: Create Tool Result Message

## Target
User story: 02-single-glob-call

## Agent
model: haiku

### Pre-read Skills
- .agents/skills/default.md
- .agents/skills/tdd.md
- .agents/skills/naming.md
- .agents/skills/coverage.md
- .agents/skills/testability.md
- .agents/skills/quality.md

### Pre-read Docs
- docs/memory.md
- docs/error_handling.md
- docs/return_values.md
- docs/architecture.md
- rel-04/user-stories/02-single-glob-call.md (see Request B for tool message format)

### Pre-read Source (patterns)
- rel-04/README.md (section "Canonical Message Format" - message structure with kind/content/data_json)
- src/openai/client.c (message creation and memory management with talloc)

### Pre-read Tests (patterns)
- tests/unit/openai/client_structures_test.c (message creation tests, TDD test patterns, talloc hierarchy verification)

## Pre-conditions
- `make check` passes
- `ik_tool_exec_glob()` exists and returns JSON result
- Task `glob-execute.md` completed

## Task
Create a canonical tool result message that can be added to conversation for Request B.

The canonical message uses `ik_msg_t` (or `ik_message_t`) with three fields:
- `kind`: "tool_result"
- `content`: Human-readable summary (e.g., "3 files found")
- `data_json`: Structured data as JSON string: `{"tool_call_id": "call_abc123", "name": "glob", "output": "{...}", "success": true}`

The OpenAI wire format `{"role": "tool", "tool_call_id": "...", "content": "..."}` is generated by the OpenAI serializer when converting canonical messages to API requests. This task creates the canonical representation only.

## TDD Cycle

### Red
1. Add tests in appropriate test file (e.g., `tests/unit/messages/test_canonical.c`):
   - `ik_msg_create_tool_result()` returns non-NULL
   - Message has `kind` = "tool_result"
   - Message has `content` field with human-readable summary
   - Message has `data_json` field with structured JSON: `{"tool_call_id": "...", "name": "...", "output": "...", "success": true}`
   - Verify talloc hierarchy (message owns its strings)
2. Add function declaration to appropriate header (e.g., `src/messages/canonical.h` or similar):
   - Declare `ik_msg_create_tool_result(void *parent, const char *tool_call_id, const char *name, const char *output, bool success, const char *content)`
3. Add stub implementation: `return NULL;`
4. Run `make check` - expect assertion failure (returns NULL, test expects valid message)

### Green
1. Replace stub with implementation:
   - Allocate `ik_msg_t` struct using talloc
   - Set `kind` to "tool_result"
   - Set `content` to human-readable summary
   - Build `data_json` string with tool_call_id, name, output, success fields
   - Ensure proper memory ownership with talloc
2. Run `make check` - expect pass

### Refactor
1. Consider extracting JSON building to helper function if complex
2. Ensure consistent memory ownership patterns with other canonical message types
3. Verify that serialization to OpenAI wire format happens separately in OpenAI serializer
4. Run `make check` - verify still green

## Post-conditions
- `make check` passes
- `make lint && make coverage` passes
- Canonical tool result message can be created with kind="tool_result", content, and data_json
- data_json contains tool_call_id, name, output, and success fields
- 100% test coverage for new code

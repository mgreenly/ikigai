# Task: Paths Module Core Implementation

**UNATTENDED EXECUTION:** This task executes automatically without human oversight. Provide complete context.

**Model:** sonnet/thinking
**Depends on:** None

## Context

**Working directory:** Project root (where `Makefile` lives)
**All paths are relative to project root**, not to this task file.

All needed context is provided in this file. Do not research, explore, or spawn sub-agents.

## Pre-Read

**Skills:**
(Baseline skills jj, errors, style, tdd are pre-loaded. Only list additional skills.)
- `/load naming` - For naming conventions and approved abbreviations
- `/load di` - For dependency injection patterns

**Plan:**
- `rel-08/plan/paths-module.md` - Complete paths module specification
- `project/install-directories.md` - Installation directory layout

**Source:**
- `src/config.c` - For tilde expansion pattern to migrate

## Libraries

Use only:
- talloc - For memory management
- Standard POSIX - For getenv

Do not introduce new dependencies.

## Preconditions

- [ ] Working copy is clean (verify with `jj diff --summary`)

## Objective

Implement the core paths module that reads installation paths from environment variables set by the wrapper script. The wrapper script (generated at install time) computes all paths and exports them as IKIGAI_*_DIR environment variables. The paths module simply reads these variables and provides convenient access through getter functions.

## Interface

Functions to implement:

| Function | Purpose |
|----------|---------|
| `res_t ik_paths_init(TALLOC_CTX *ctx, ik_paths_t **out)` | Reads paths from environment, returns OK/ERR |
| `const char *ik_paths_get_bin_dir(ik_paths_t *paths)` | Returns bin directory path (never NULL) |
| `const char *ik_paths_get_config_dir(ik_paths_t *paths)` | Returns config directory path (never NULL) |
| `const char *ik_paths_get_data_dir(ik_paths_t *paths)` | Returns data directory path (never NULL) |
| `const char *ik_paths_get_libexec_dir(ik_paths_t *paths)` | Returns libexec directory path (never NULL) |
| `const char *ik_paths_get_tools_system_dir(ik_paths_t *paths)` | Returns system tools directory (same as libexec) |
| `const char *ik_paths_get_tools_user_dir(ik_paths_t *paths)` | Returns user tools directory path (never NULL) |
| `const char *ik_paths_get_tools_project_dir(ik_paths_t *paths)` | Returns project tools directory path (never NULL) |
| `res_t ik_paths_expand_tilde(TALLOC_CTX *ctx, const char *path, char **out)` | Expands ~ to $HOME, returns OK/ERR (PUBLIC API) |

Structs to define:

| Struct | Members | Purpose |
|--------|---------|---------|
| `ik_paths_t` | bin_dir, config_dir, data_dir, libexec_dir, tools_user_dir, tools_project_dir | Holds resolved paths from environment |

**Note:** Struct is PRIVATE (defined only in src/paths.c). Header only has opaque typedef.

## Behaviors

### Environment Variables (Set by Wrapper Script)

The wrapper script (generated by `make install`) sets these variables before exec'ing the binary:

- `IKIGAI_BIN_DIR` - Binary directory (e.g., `/usr/local/bin`)
- `IKIGAI_CONFIG_DIR` - Config directory (e.g., `/usr/local/etc/ikigai` or `/etc/ikigai`)
- `IKIGAI_DATA_DIR` - Data directory (e.g., `/usr/local/share/ikigai`)
- `IKIGAI_LIBEXEC_DIR` - Libexec directory (e.g., `/usr/local/libexec/ikigai`)

**Wrapper script example (PREFIX=/usr/local):**
```bash
#!/bin/sh
IKIGAI_BIN_DIR=/usr/local/bin
IKIGAI_CONFIG_DIR=/usr/local/etc/ikigai
IKIGAI_DATA_DIR=/usr/local/share/ikigai
IKIGAI_LIBEXEC_DIR=/usr/local/libexec/ikigai
export IKIGAI_BIN_DIR IKIGAI_CONFIG_DIR IKIGAI_DATA_DIR IKIGAI_LIBEXEC_DIR
exec /usr/local/libexec/ikigai/ikigai "$@"
```

### ik_paths_init() Behavior

**Success case:**
1. Read `IKIGAI_BIN_DIR` from environment
2. Read `IKIGAI_CONFIG_DIR` from environment
3. Read `IKIGAI_DATA_DIR` from environment
4. Read `IKIGAI_LIBEXEC_DIR` from environment
5. If all 4 variables are set:
   - Allocate `ik_paths_t` on ctx
   - Copy each path as talloc child of paths instance
   - Set `tools_user_dir` to `~/.ikigai/tools/` (expanded)
   - Set `tools_project_dir` to `.ikigai/tools/`
   - Return OK with paths instance

**Error case:**
- If any of the 4 environment variables is missing or empty:
  - Allocate error on ctx: `ERR(ctx, ERR_INVALID_ARG, "Missing required environment variable IKIGAI_*_DIR")`
  - Return error result
  - Do NOT allocate paths instance

**Development mode:**
For development (running from source without wrapper script), use direnv with `.envrc`:
```bash
# .envrc in project root
export IKIGAI_BIN_DIR=$PWD/bin
export IKIGAI_CONFIG_DIR=$PWD/etc/ikigai
export IKIGAI_DATA_DIR=$PWD/share/ikigai
export IKIGAI_LIBEXEC_DIR=$PWD/libexec/ikigai
```

### Getter Functions Behavior

All getters:
- Assert `paths != NULL`
- Return corresponding field from struct
- Return `const char *` (caller must NOT free)
- Never return NULL (paths_init guarantees all fields populated)

**Special getter - tools_system_dir:**
Returns same as `libexec_dir` (system tools live in libexec directory).

### Tilde Expansion (PUBLIC API)

**Behavior:**
- Input `~/foo` → Output `$HOME/foo`
- Input `/absolute/path` → Output `/absolute/path` (unchanged)
- Input `relative/path` → Output `relative/path` (unchanged)
- Input `~` alone → Output `$HOME`
- Input `foo~/bar` → Output `foo~/bar` (tilde not at start, unchanged)

**Error handling:**
- If `$HOME` not set and tilde expansion needed: Return `ERR(ctx, ERR_IO, "HOME environment variable not set")`
- If path is NULL: Return `ERR(ctx, ERR_INVALID_ARG, "path is NULL")`
- If allocation fails: PANIC

**Implementation pattern:**
```c
res_t ik_paths_expand_tilde(TALLOC_CTX *ctx, const char *path, char **out)
{
    if (path == NULL) {
        return ERR(ctx, ERR_INVALID_ARG, "path is NULL");
    }

    // Check if path starts with ~/ or is exactly ~
    if (path[0] != '~' || (path[1] != '\0' && path[1] != '/')) {
        // No tilde at start, return copy unchanged
        *out = talloc_strdup(ctx, path);
        if (*out == NULL) PANIC("Out of memory");  // LCOV_EXCL_BR_LINE
        return OK(NULL);
    }

    // Get HOME
    const char *home = getenv("HOME");
    if (home == NULL) {
        return ERR(ctx, ERR_IO, "HOME environment variable not set");
    }

    // Build expanded path
    if (path[1] == '\0') {
        // Just ~
        *out = talloc_strdup(ctx, home);
    } else {
        // ~/something
        *out = talloc_asprintf(ctx, "%s%s", home, path + 1);
    }

    if (*out == NULL) PANIC("Out of memory");  // LCOV_EXCL_BR_LINE
    return OK(NULL);
}
```

### Memory Management

- All strings in `ik_paths_t` are talloc-allocated children of the paths instance
- Caller owns the paths instance (allocated on provided context)
- String getters return `const char *` - callers must NOT free them
- Freeing the paths instance frees all internal strings

## Test Implementation

**Follow TDD workflow (Red/Green/Verify):**

**Step 1 - Red (Failing Test):**

Create test file `tests/unit/paths/paths_test.c` with test cases:

1. `test_paths_init_success` - Verify successful initialization when all env vars set
2. `test_paths_init_missing_bin_dir` - Verify ERR_INVALID_ARG when IKIGAI_BIN_DIR missing
3. `test_paths_init_missing_config_dir` - Verify ERR_INVALID_ARG when IKIGAI_CONFIG_DIR missing
4. `test_paths_init_missing_data_dir` - Verify ERR_INVALID_ARG when IKIGAI_DATA_DIR missing
5. `test_paths_init_missing_libexec_dir` - Verify ERR_INVALID_ARG when IKIGAI_LIBEXEC_DIR missing
6. `test_paths_get_bin_dir` - Verify getter returns correct value
7. `test_paths_get_config_dir` - Verify getter returns correct value
8. `test_paths_get_data_dir` - Verify getter returns correct value
9. `test_paths_get_libexec_dir` - Verify getter returns correct value
10. `test_paths_get_tools_system_dir` - Verify returns same as libexec_dir
11. `test_paths_get_tools_user_dir` - Verify returns `~/.ikigai/tools/` (expanded)
12. `test_paths_get_tools_project_dir` - Verify returns `.ikigai/tools/`
13. `test_paths_expand_tilde_home` - Verify `~/foo` → `$HOME/foo`
14. `test_paths_expand_tilde_alone` - Verify `~` → `$HOME`
15. `test_paths_expand_tilde_not_at_start` - Verify `foo~/bar` unchanged
16. `test_paths_expand_tilde_absolute` - Verify `/absolute` unchanged
17. `test_paths_expand_tilde_relative` - Verify `relative` unchanged
18. `test_paths_expand_tilde_no_home` - Verify ERR_IO when HOME not set
19. `test_paths_expand_tilde_null_input` - Verify ERR_INVALID_ARG

**Test pattern:**
```c
START_TEST(test_paths_init_success)
{
    // Setup environment
    setenv("IKIGAI_BIN_DIR", "/test/bin", 1);
    setenv("IKIGAI_CONFIG_DIR", "/test/config", 1);
    setenv("IKIGAI_DATA_DIR", "/test/data", 1);
    setenv("IKIGAI_LIBEXEC_DIR", "/test/libexec", 1);

    // Execute
    ik_paths_t *paths = NULL;
    res_t result = ik_paths_init(test_ctx, &paths);

    // Assert
    ck_assert(is_ok(&result));
    ck_assert_ptr_nonnull(paths);
    ck_assert_str_eq(ik_paths_get_bin_dir(paths), "/test/bin");
    ck_assert_str_eq(ik_paths_get_config_dir(paths), "/test/config");

    // Cleanup
    unsetenv("IKIGAI_BIN_DIR");
    unsetenv("IKIGAI_CONFIG_DIR");
    unsetenv("IKIGAI_DATA_DIR");
    unsetenv("IKIGAI_LIBEXEC_DIR");
}
END_TEST
```

Add function declarations to `src/paths.h`:
```c
// Opaque type
typedef struct ik_paths_t ik_paths_t;

// Functions
res_t ik_paths_init(TALLOC_CTX *ctx, ik_paths_t **out);
const char *ik_paths_get_bin_dir(ik_paths_t *paths);
const char *ik_paths_get_config_dir(ik_paths_t *paths);
const char *ik_paths_get_data_dir(ik_paths_t *paths);
const char *ik_paths_get_libexec_dir(ik_paths_t *paths);
const char *ik_paths_get_tools_system_dir(ik_paths_t *paths);
const char *ik_paths_get_tools_user_dir(ik_paths_t *paths);
const char *ik_paths_get_tools_project_dir(ik_paths_t *paths);
res_t ik_paths_expand_tilde(TALLOC_CTX *ctx, const char *path, char **out);
```

Add stub implementations to `src/paths.c`:
```c
// Private struct definition (NOT in header)
struct ik_paths_t {
    char *bin_dir;
    char *config_dir;
    char *data_dir;
    char *libexec_dir;
    char *tools_user_dir;
    char *tools_project_dir;
};

res_t ik_paths_init(TALLOC_CTX *ctx, ik_paths_t **out) {
    return OK(NULL);
}

const char *ik_paths_get_bin_dir(ik_paths_t *paths) {
    return NULL;
}

// ... etc
```

Build and run: `make check`

Verify tests FAIL with assertion failures (NOT compilation errors).

**Step 2 - Green (Minimal Implementation):**

Implement each function to make tests pass:

1. Implement `ik_paths_init()`:
   - Read 4 environment variables using `getenv()`
   - Check if any is NULL or empty
   - If missing: return `ERR(ctx, ERR_INVALID_ARG, "Missing IKIGAI_*_DIR")`
   - Allocate `ik_paths_t` on ctx
   - Copy all paths using `talloc_strdup()`
   - Expand tilde for user/project tools dirs
   - Return OK with paths instance

2. Implement getter functions:
   - Assert `paths != NULL`
   - Return corresponding field
   - `tools_system_dir` returns `libexec_dir`

3. Implement `ik_paths_expand_tilde()`:
   - Check for NULL input
   - Check if path starts with `~`
   - Get HOME environment variable
   - Build expanded path
   - Return OK with result

STOP when all tests pass.

**Step 3 - Verify:**
- Run `make check` - all tests must pass
- Run `make lint` - complexity under threshold

## Completion

After completing work (whether success, partial, or failed), commit all changes:

```bash
jj commit -m "$(cat <<'EOF'
task(paths-core.md): [success|partial|failed] - [brief description]

[Optional: Details about what was accomplished, failures, or remaining work]
EOF
)"
```

Report status to orchestration:
- Success: Task complete, all tests passing
- Partial/Failed: Describe what's incomplete or failing

## Postconditions

- [ ] Compiles without warnings
- [ ] All tests pass (19 test cases)
- [ ] `make check` passes
- [ ] All changes committed using commit message template
- [ ] Working copy is clean (no uncommitted changes)

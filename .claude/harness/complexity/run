#!/usr/bin/env ruby
# frozen_string_literal: true

#
# harness/complexity - Complexity check
#
# Runs make check-complexity, parses complex functions, outputs JSON summary.
# No fix functionality - check only.
#

require 'json'
require 'optparse'
require 'fileutils'
require 'set'

# Run command and capture output, suppressing all output
def run_cmd(cmd, env: {})
  stdout_str = ''
  status = nil

  # Merge environment variables
  full_env = ENV.to_h.merge(env)

  IO.popen(full_env, cmd, err: [:child, :out]) do |io|
    stdout_str = io.read
  end
  status = $?

  [status.exitstatus, stdout_str]
end

# Run make check-complexity with parallelization
def run_make_complexity
  # Try parallel first
  exit_code, output = run_cmd(['make', 'check-complexity'])

  # If failed, re-run serially for clean error output
  if exit_code != 0
    exit_code, output = run_cmd(['make', 'MAKE_JOBS=1', 'check-complexity'])
  end

  [exit_code == 0, output]
end

# Parse make check-complexity output to extract complex functions
def parse_failures(output)
  failures = []
  seen = Set.new

  # Pattern for complexity scores:
  # Score | ln-ct | nc-lns| file-name(line): proc-name
  #    15      42      35   src/foo.c(123): some_function
  score_pattern = /^\s*(\d+)\s+\d+\s+\d+\s+(\S+)\((\d+)\):\s+(\S+)/

  # Pattern for nesting depth:
  # complexity: /path/to/file.c:123: nesting depth reached level 6 in function_name
  nesting_pattern = /complexity:\s*(\S+):(\d+):\s*nesting depth reached level (\d+)\s+in\s+(\S+)/

  output.scan(score_pattern) do |score, file, line, function|
    key = [file, function]
    unless seen.include?(key)
      seen.add(key)
      failures << {
        file: file,
        line: line,
        function: function,
        score: score.to_i,
        issue_type: 'complexity'
      }
    end
  end

  output.scan(nesting_pattern) do |file, line, depth, function|
    key = [file, function]
    unless seen.include?(key)
      seen.add(key)
      failures << {
        file: file,
        line: line,
        function: function,
        score: depth.to_i,
        issue_type: 'nesting'
      }
    end
  end

  failures
end

# Format failure item based on issue type
def format_failure_item(failure)
  if failure[:issue_type] == 'nesting'
    "#{failure[:file]}:#{failure[:function]} nesting=#{failure[:score]}"
  else
    "#{failure[:file]}:#{failure[:function]} complexity=#{failure[:score]}"
  end
end

def main
  options = {}

  OptionParser.new do |opts|
    opts.banner = 'Usage: run.rb [options]'
    opts.on('--file FILE', 'Filter results to specific file') do |f|
      options[:file] = f
    end
  end.parse!

  # Change to project root (3 levels up from harness/complexity/)
  script_dir = File.dirname(File.realpath(__FILE__))
  project_root = File.expand_path('../../..', script_dir)
  Dir.chdir(project_root)

  # Check file existence early if --file is specified
  if options[:file]
    target_file = options[:file]
    unless File.exist?(target_file)
      puts JSON.generate(ok: false, items: ["#{target_file}: file not found"])
      exit 1
    end
  end

  # Run complexity check
  success, output = run_make_complexity

  if success
    puts JSON.generate(ok: true)
    exit 0
  end

  # Parse failures
  failures = parse_failures(output)

  # Filter to target file if --file is specified
  if options[:file]
    target_file = options[:file]
    failures = failures.select { |f| f[:file] == target_file }

    if failures.empty?
      # File exists, no complexity issues
      puts JSON.generate(ok: true)
      exit 0
    end
  end

  if failures.empty?
    # Check failed but couldn't parse failures
    puts JSON.generate(ok: false, items: [])
    exit 1
  end

  # Format and output failures
  items = failures.map { |f| format_failure_item(f) }
  puts JSON.generate(ok: false, items: items)
  exit 1
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end

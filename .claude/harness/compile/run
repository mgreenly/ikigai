#!/usr/bin/env ruby
# frozen_string_literal: true

#
# harness/compile - Compile error check
#
# Runs make check-compile, parses compile errors, outputs JSON summary.
# No fix functionality - check only.
#

require 'json'
require 'optparse'
require 'fileutils'

# Run command and capture output, suppressing all output
def run_cmd(cmd, env: {})
  stdout_str = ''
  stderr_str = ''
  status = nil

  # Merge environment variables
  full_env = ENV.to_h.merge(env)

  IO.popen(full_env, cmd, err: [:child, :out]) do |io|
    stdout_str = io.read
  end
  status = $?

  [status.exitstatus, stdout_str]
end

# Parse compiler errors from make check-compile output
def parse_errors(output)
  errors = []
  seen_files = Set.new

  # Two output formats:
  # 1. With FILE=: ğŸ”´ file.c:123:45: error: message (detailed)
  # 2. Without FILE=: ğŸ”´ file.c (summary only)
  detailed_pattern = /^ğŸ”´ ([^\s:]+):(\d+):(\d+):\s*error:\s*(.+)$/
  summary_pattern = /^ğŸ”´ ([^\s]+\.c)$/

  output.each_line do |line|
    if line =~ detailed_pattern
      file, line_num, col, message = $1, $2, $3, $4

      # Only report first error per file (they often cascade)
      next if seen_files.include?(file)
      seen_files.add(file)

      errors << {
        file: file,
        line: line_num,
        col: col,
        message: message
      }
    elsif line =~ summary_pattern
      file = $1

      # Only report first error per file
      next if seen_files.include?(file)
      seen_files.add(file)

      errors << {
        file: file,
        line: '1',
        col: '1',
        message: 'compilation failed'
      }
    end
  end

  errors
end

# Format error dict as 'file:line:col: message' string
def format_error_item(error)
  "#{error[:file]}:#{error[:line]}:#{error[:col]}: #{error[:message]}"
end

# Run make check-compile
def run_make_build(file: nil)
  cmd = ['make', 'check-compile']
  cmd << "FILE=#{file}" if file

  exit_code, output = run_cmd(cmd)

  [exit_code == 0, output]
end

def main
  options = {}

  OptionParser.new do |opts|
    opts.banner = 'Usage: run.rb [options]'
    opts.on('--file FILE', 'Filter results to specific file') do |f|
      options[:file] = f
    end
  end.parse!

  # Change to project root (3 levels up from harness/compile/)
  script_dir = File.dirname(File.realpath(__FILE__))
  project_root = File.expand_path('../../..', script_dir)
  Dir.chdir(project_root)

  # Check file existence early if --file is specified
  if options[:file]
    target_file = options[:file]
    unless File.exist?(target_file)
      puts JSON.generate(ok: false, items: ["#{target_file}: file not found"])
      exit 1
    end
  end

  # Run make clean first
  run_cmd(['make', 'clean'])

  # Run build
  success, output = run_make_build(file: options[:file])

  # Parse errors
  errors = parse_errors(output)

  if errors.empty?
    # No errors found - success
    puts JSON.generate(ok: true)
    exit 0
  end

  # Format and output errors
  items = errors.map { |e| format_error_item(e) }
  puts JSON.generate(ok: false, items: items)
  exit 1
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end

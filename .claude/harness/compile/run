#!/usr/bin/env ruby
# frozen_string_literal: true

#
# harness/compile - Compile/link error check
#
# Runs make, parses compile/link errors, outputs JSON summary.
# No fix functionality - check only.
#

require 'json'
require 'optparse'
require 'fileutils'

# Run command and capture output, suppressing all output
def run_cmd(cmd, env: {})
  stdout_str = ''
  stderr_str = ''
  status = nil

  # Merge environment variables
  full_env = ENV.to_h.merge(env)

  IO.popen(full_env, cmd, err: [:child, :out]) do |io|
    stdout_str = io.read
  end
  status = $?

  [status.exitstatus, stdout_str]
end

# Parse compiler/linker errors from make output
def parse_errors(output)
  errors = []
  seen_files = Set.new

  # GCC/Clang error pattern: file.c:123:45: error: message
  error_pattern = /^([^\s:]+):(\d+):(\d+):\s*error:\s*(.+)$/

  # First try compiler errors
  output.scan(error_pattern) do |file, line, col, message|
    # Only report first error per file (they often cascade)
    next if seen_files.include?(file)
    seen_files.add(file)

    errors << {
      file: file,
      line: line,
      col: col,
      message: message
    }
  end

  # If no compiler errors, check for linker errors
  if errors.empty?
    # Linker error pattern: undefined reference to `symbol'
    linker_matches = output.scan(/undefined reference to [`']([^'`]+)[`']/)

    unless linker_matches.empty?
      # Try to find the object file being linked
      obj_match = output.match(/([^\s]+\.o):/)

      errors << {
        file: obj_match ? obj_match[1] : 'unknown',
        line: '1',
        col: '1',
        message: "undefined reference to: #{linker_matches.flatten.take(3).join(', ')}"
      }
    end
  end

  errors
end

# Format error dict as 'file:line:col: message' string
def format_error_item(error)
  "#{error[:file]}:#{error[:line]}:#{error[:col]}: #{error[:message]}"
end

# Run make with appropriate parallelization
def run_make_build
  exit_code, output = run_cmd(['make', 'all', 'build-tests'])

  [exit_code == 0, output]
end

def main
  options = {}

  OptionParser.new do |opts|
    opts.banner = 'Usage: run.rb [options]'
    opts.on('--file FILE', 'Filter results to specific file') do |f|
      options[:file] = f
    end
  end.parse!

  # Change to project root (3 levels up from harness/compile/)
  script_dir = File.dirname(File.realpath(__FILE__))
  project_root = File.expand_path('../../..', script_dir)
  Dir.chdir(project_root)

  # Check file existence early if --file is specified
  if options[:file]
    target_file = options[:file]
    unless File.exist?(target_file)
      puts JSON.generate(ok: false, items: ["#{target_file}: file not found"])
      exit 1
    end
  end

  # Run make clean first
  run_cmd(['make', 'clean'])

  # Run build
  success, output = run_make_build

  if success
    puts JSON.generate(ok: true)
    exit 0
  end

  # Parse errors
  errors = parse_errors(output)

  # Filter errors to target file if --file is specified
  if options[:file]
    target_file = options[:file]
    errors = errors.select { |e| e[:file] == target_file }

    if errors.empty?
      # File exists, no errors - success
      puts JSON.generate(ok: true)
      exit 0
    end
  end

  if errors.empty?
    # Build failed but couldn't parse errors
    puts JSON.generate(ok: false, items: [])
    exit 1
  end

  # Format and output errors
  items = errors.map { |e| format_error_item(e) }
  puts JSON.generate(ok: false, items: items)
  exit 1
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end

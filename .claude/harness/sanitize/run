#!/usr/bin/env python3
import sys
sys.dont_write_bytecode = True
"""
harness/sanitize - Automated sanitizer error fix loop

Runs make check-sanitize (ASan + UBSan), fixes errors one at a time with
escalation, commits on success, reverts on exhaustion, continues until
all pass or no progress is made.
"""

import argparse
import subprocess
import sys
import os
import re
from datetime import datetime
from pathlib import Path

# Configuration
MAX_ATTEMPTS_PER_FILE = 3

# Escalation ladder: (model, thinking_budget, display_name)
ESCALATION_LADDER = {
    1: ("claude-sonnet-4-20250514", "10000", "sonnet:think"),
    2: ("claude-opus-4-20250514", "10000", "opus:think"),
    3: ("claude-opus-4-20250514", "128000", "opus:ultrathink"),
}

SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent.parent.parent
FIX_PROMPT_TEMPLATE = SCRIPT_DIR / "fix.prompt.md"


def log(msg: str) -> None:
    """Print timestamped log message."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"{timestamp} | sanitize | {msg}", flush=True)


def run_cmd(cmd: list[str], capture: bool = True, cwd: Path | None = None, timeout: int | None = None) -> tuple[int, str, str]:
    """Run a command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        cmd,
        capture_output=capture,
        text=True,
        cwd=cwd or PROJECT_ROOT,
        timeout=timeout,
    )
    return result.returncode, result.stdout or "", result.stderr or ""


def run_make_sanitize() -> tuple[bool, str]:
    """Run make check-sanitize and return (success, output)."""
    log("Running make check-sanitize...")
    code, stdout, stderr = run_cmd(["make", "check-sanitize"], timeout=600)
    output = stdout + stderr
    return code == 0, output


def parse_failures(output: str) -> list[dict]:
    """
    Parse sanitizer output to extract errors.
    Returns list of {file, line, error_type, message, stack} dicts.
    """
    failures = []
    seen_files = set()

    # AddressSanitizer pattern:
    # ==PID==ERROR: AddressSanitizer: error-type on address ...
    #     #0 0x... in function file.c:123
    asan_error = re.compile(r'==\d+==ERROR: AddressSanitizer: ([^\n]+)')
    asan_location = re.compile(r'#\d+\s+0x[0-9a-f]+\s+in\s+\S+\s+(\S+):(\d+)')

    # UndefinedBehaviorSanitizer pattern:
    # file.c:123:45: runtime error: description
    ubsan_pattern = re.compile(r'(\S+):(\d+):\d+:\s*runtime error:\s*(.+)')

    # LeakSanitizer pattern:
    # Direct leak of N byte(s) in M object(s) allocated from:
    #     #0 0x... in function file.c:123
    lsan_error = re.compile(r'(Direct|Indirect) leak of \d+ byte')
    lsan_location = re.compile(r'#\d+\s+0x[0-9a-f]+\s+in\s+\S+\s+(\S+):(\d+)')

    lines = output.split('\n')
    i = 0
    while i < len(lines):
        line = lines[i]

        # Check for ASan error
        asan_match = asan_error.search(line)
        if asan_match:
            error_type = asan_match.group(1).strip()
            # Look for source location in next few lines
            stack = []
            for j in range(i + 1, min(i + 20, len(lines))):
                loc_match = asan_location.search(lines[j])
                if loc_match:
                    file = loc_match.group(1)
                    line_num = loc_match.group(2)
                    stack.append(f"{file}:{line_num}")
                    # Use first source file location (not libc, etc.)
                    if file not in seen_files and (file.startswith('src/') or file.startswith('tests/')):
                        seen_files.add(file)
                        failures.append({
                            "file": file,
                            "line": line_num,
                            "error_type": f"ASan: {error_type}",
                            "message": error_type,
                            "stack": '\n'.join(stack[:10]),
                        })
                        break
            i += 1
            continue

        # Check for UBSan error
        ubsan_match = ubsan_pattern.search(line)
        if ubsan_match:
            file = ubsan_match.group(1)
            line_num = ubsan_match.group(2)
            message = ubsan_match.group(3)
            if file not in seen_files and (file.startswith('src/') or file.startswith('tests/')):
                seen_files.add(file)
                failures.append({
                    "file": file,
                    "line": line_num,
                    "error_type": "UBSan",
                    "message": message,
                    "stack": "",
                })
            i += 1
            continue

        # Check for LSan error
        lsan_match = lsan_error.search(line)
        if lsan_match:
            leak_type = lsan_match.group(1)
            # Look for source location
            for j in range(i + 1, min(i + 20, len(lines))):
                loc_match = lsan_location.search(lines[j])
                if loc_match:
                    file = loc_match.group(1)
                    line_num = loc_match.group(2)
                    if file not in seen_files and (file.startswith('src/') or file.startswith('tests/')):
                        seen_files.add(file)
                        failures.append({
                            "file": file,
                            "line": line_num,
                            "error_type": f"LSan: {leak_type} leak",
                            "message": f"{leak_type} memory leak",
                            "stack": "",
                        })
                        break
            i += 1
            continue

        i += 1

    return failures


def load_prompt_template() -> str:
    """Load the fix prompt template."""
    if not FIX_PROMPT_TEMPLATE.exists():
        log(f"ERROR: Missing {FIX_PROMPT_TEMPLATE}")
        sys.exit(1)
    return FIX_PROMPT_TEMPLATE.read_text()


def build_prompt(failure: dict, make_output: str) -> str:
    """Build the fix prompt from template."""
    template = load_prompt_template()

    prompt = template.replace("{{file}}", failure["file"])
    prompt = prompt.replace("{{line}}", failure["line"])
    prompt = prompt.replace("{{error_type}}", failure["error_type"])
    prompt = prompt.replace("{{message}}", failure["message"])
    prompt = prompt.replace("{{stack}}", failure["stack"])
    prompt = prompt.replace("{{make_output}}", make_output[-6000:])

    return prompt


def invoke_claude(prompt: str, model: str, thinking_budget: str) -> tuple[bool, str]:
    """
    Invoke Claude CLI with the prompt via stdin.
    Returns (success, response).
    """
    import json
    import tempfile

    with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
        f.write(prompt)
        prompt_file = f.name

    try:
        cmd = f'cat "{prompt_file}" | claude -p - --model {model} --allowedTools "Read,Edit,Write,Bash,Glob,Grep" --output-format json --max-turns 30'
        env = os.environ.copy()
        env["MAX_THINKING_TOKENS"] = thinking_budget
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            cwd=PROJECT_ROOT,
            timeout=900,
            env=env,
        )
        code = result.returncode
        stdout = result.stdout or ""
        stderr = result.stderr or ""
    finally:
        Path(prompt_file).unlink(missing_ok=True)

    if code != 0:
        return False, stderr

    try:
        result = json.loads(stdout)
        return True, result.get("result", "")
    except json.JSONDecodeError:
        return True, stdout


def git_get_modified_files() -> set[str]:
    """Get set of currently modified/untracked files."""
    code, stdout, _ = run_cmd(["git", "status", "--porcelain"])
    files = set()
    for line in stdout.strip().split('\n'):
        if line.strip():
            parts = line[3:].split(' -> ')
            files.add(parts[-1])
    return files


def git_commit(failure: dict, model_name: str, attempt: int, files_before: set[str]) -> bool:
    """Commit only files that changed during fix attempt."""
    files_after = git_get_modified_files()
    new_changes = files_after - files_before

    if not new_changes:
        return False

    for f in new_changes:
        run_cmd(["git", "add", f])

    file_name = Path(failure["file"]).name
    error_type = failure["error_type"].split(':')[0]  # ASan, UBSan, or LSan
    msg = f"fix: {error_type} error in {file_name}\n\nharness/sanitize | {model_name} | attempt {attempt}"

    code, _, _ = run_cmd(["git", "commit", "-m", msg])
    return code == 0


def git_revert(files_before: set[str] | None = None) -> None:
    """Revert changes made during fix attempt."""
    if files_before is not None:
        files_after = git_get_modified_files()
        new_changes = files_after - files_before
        if new_changes:
            log("Reverting uncommitted changes...")
            for f in new_changes:
                run_cmd(["git", "checkout", f])
            run_cmd(["git", "clean", "-fd", "src/", "tests/"])
    else:
        code, stdout, _ = run_cmd(["git", "status", "--porcelain"])
        if stdout.strip():
            log("Reverting uncommitted changes...")
            run_cmd(["git", "checkout", "."])
            run_cmd(["git", "clean", "-fd"])


def try_fix_file(failure: dict, make_output: str) -> bool:
    """
    Attempt to fix a sanitizer error.
    Returns True if fixed, False if exhausted attempts.
    """
    file = failure["file"]

    files_before = git_get_modified_files()

    for attempt in range(1, MAX_ATTEMPTS_PER_FILE + 1):
        model, thinking_budget, model_name = ESCALATION_LADDER[attempt]

        log(f"Trying {model_name} (attempt {attempt}/{MAX_ATTEMPTS_PER_FILE})")

        prompt = build_prompt(failure, make_output)
        success, response = invoke_claude(prompt, model, thinking_budget)

        if not success:
            log(f"{model_name} invocation FAILED: {response[:200]}")
            continue

        # Verify the fix
        check_passed, _ = run_make_sanitize()

        if check_passed:
            log(f"{model_name} SUCCESS")
            git_commit(failure, model_name, attempt, files_before)
            return True
        else:
            log(f"{model_name} FAILED (sanitizer errors remain)")

    # Exhausted all attempts
    log(f"SKIPPED - exhausted {MAX_ATTEMPTS_PER_FILE} attempts")
    git_revert(files_before)
    return False


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Automated sanitizer error fix loop")
    parser.add_argument("--dry-run", action="store_true",
                        help="Identify sanitizer errors without fixing them")
    args = parser.parse_args()

    log("Starting" + (" (dry-run)" if args.dry_run else ""))
    os.chdir(PROJECT_ROOT)

    # Run sanitizer check
    success, output = run_make_sanitize()

    if success:
        log("All sanitizer checks passed!")
        return 0

    failures = parse_failures(output)

    if not failures:
        log("make check-sanitize failed but couldn't parse failures")
        log("Output tail:")
        for line in output.split('\n')[-30:]:
            log(f"  {line}")
        return 1

    log(f"Found {len(failures)} sanitizer errors")

    # Dry-run: just list failures and exit
    if args.dry_run:
        log("Errors needing fixes:")
        for failure in failures:
            log(f"  - {failure['file']}:{failure['line']} - {failure['error_type']}")
        return 0

    pass_num = 0

    while True:
        pass_num += 1
        log(f"=== Pass {pass_num} ===")

        if pass_num > 1:
            # Re-run check for subsequent passes
            success, output = run_make_sanitize()

            if success:
                log("All sanitizer checks passed!")
                return 0

            failures = parse_failures(output)

            if not failures:
                log("make check-sanitize failed but couldn't parse failures")
                log("Output tail:")
                for line in output.split('\n')[-30:]:
                    log(f"  {line}")
                return 1

            log(f"Found {len(failures)} sanitizer errors")

        fixed_count = 0
        skipped = []

        for i, failure in enumerate(failures, 1):
            file = failure["file"]
            error = failure["error_type"]
            log(f"[{i}/{len(failures)}] {file}:{failure['line']} - {error}")

            if try_fix_file(failure, output):
                fixed_count += 1
            else:
                skipped.append(f"{file}:{failure['line']}")

        log(f"Pass {pass_num} complete: {fixed_count} fixed, {len(skipped)} skipped")

        if fixed_count == 0:
            log("No progress made. Stopping.")
            if skipped:
                log("Skipped errors:")
                for f in skipped:
                    log(f"  - {f}")
            return 1


if __name__ == "__main__":
    sys.exit(main())

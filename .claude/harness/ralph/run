#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'optparse'
require 'shellwords'
require 'time'
require 'erb'
require 'tempfile'
require 'fileutils'

# Resolve script directory at load time (before any chdir)
SCRIPT_DIR = File.dirname(File.realpath(__FILE__))
STATE_DIR = File.join(ENV['HOME'], '.local', 'state', 'ralph')
GOALS_DIR = File.join(STATE_DIR, 'goals')
STATS_FILE = File.join(STATE_DIR, 'stats.jsonl')

# Ralph: Iterative goal completion harness
class Ralph
  VERSION = '0.3.0'

  MAX_RECENT = 10
  SUMMARY_INTERVAL = MAX_RECENT / 2

  SPINNER_FRAMES = %w[⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏].freeze

  PROGRESS_SCHEMA = '{"type":"object","properties":{"summary":{"type":"string"}},"required":["summary"]}'

  MAX_THINKING_BUDGET = {
    'haiku' => 16_384,
    'sonnet' => 32_768,
    'opus' => 16_384
  }.freeze

  REASONING_MULTIPLIERS = {
    'none' => 0.0,
    'low' => 0.25,
    'med' => 0.5,
    'high' => 1.0
  }.freeze

  RALPH_QUOTES = [
    "Me fail English? That's unpossible!",
    "I choo-choo-choose you!",
    "Hi, Super Nintendo Chalmers!",
    "I'm in danger!",
    "My cat's breath smells like cat food.",
    "I bent my Wookie.",
    "I ate the blue ones... they taste like burning.",
    "He told me to burn things.",
    "When I grow up I wanna be a principal or a caterpillar.",
    "Go banana!"
  ].freeze

  # Model pricing (USD per million tokens) - updated 2025-01-13
  MODEL_PRICING = {
    'haiku' => { input: 0.80, output: 4.00, cache_read: 0.08, cache_create: 1.00 },
    'sonnet' => { input: 3.00, output: 15.00, cache_read: 0.30, cache_create: 3.75 },
    'opus' => { input: 15.00, output: 75.00, cache_read: 1.50, cache_create: 18.75 }
  }.freeze

  def initialize(goal_file:, duration:, model:, reasoning:, no_spinner:, no_art:, continue_run:, no_quotes:, debug:, pull_request:)
    @goal_file = goal_file
    @duration_seconds = parse_duration(duration)
    @model = model
    @reasoning = reasoning
    @thinking_budget = calculate_thinking_budget(model, reasoning)
    @summarizer_budget = calculate_thinking_budget('haiku', 'high')
    @no_spinner = no_spinner
    @no_art = no_art
    @no_quotes = no_quotes
    @continue_run = continue_run
    @debug = debug
    @pull_request = pull_request

    @start_time = Time.now
    @iteration = 0
    @spinner_thread = nil
    @spinner_running = false
    @waiting_timer_thread = nil
    @waiting_timer_running = false
    @waiting_timer_displayed = false
    @last_output_time = Time.now

    # Running totals across all goals
    @total_iterations = 0
    @total_assistant_messages = 0
    @total_tool_uses = 0
    @total_tokens = { input: 0, output: 0, cache_read: 0, cache_create: 0 }
    @total_cost = 0.0
    @total_llm_time = 0.0
    @total_tool_time = 0.0

    set_goal_paths(@goal_file)

    # Prompt templates
    @prompt_template = File.join(SCRIPT_DIR, 'prompt.md.erb')
    @summarizer_template = File.join(SCRIPT_DIR, 'summarizer.md.erb')
  end

  def set_goal_paths(goal_file)
    # Derive state file paths from goal file
    base = goal_file.sub(/-goal\.md$/, '').sub(/\.md$/, '')
    @progress_file = "#{base}-progress.jsonl"
    @summary_file = "#{base}-summary.md"
    @summary_meta_file = "#{base}-summary-meta.json"

    # Derive branch name from goal file (e.g., rel-08/feature-xyz-goal.md -> feature-xyz)
    @branch_name = File.basename(goal_file).sub(/-goal\.md$/, '').sub(/\.md$/, '')
  end

  def run
    set_goal_paths(@goal_file)
    validate_files
    copy_goal_file
    initialize_state unless @continue_run
    load_state if @continue_run

    display_header
    display_goal
    sleep 2
    display_continue_status
    handle_dirty_state
    create_bookmark_if_needed
    summarize_if_needed if @continue_run

    @exit_reason = nil
    loop do
      if time_expired?
        @exit_reason = :timeout
        break
      end

      @iteration += 1
      result = run_iteration

      if result == 'DONE'
        @exit_reason = :done
        break
      end

      summarize_if_needed
    end

    display_summary
    send_notification
  end

  def interrupt!
    @exit_reason = :interrupted
    send_notification
  end

  private

  # ─────────────────────────────────────────────────────────────
  # Setup & State
  # ─────────────────────────────────────────────────────────────

  def validate_files
    unless File.exist?(@goal_file)
      fatal "Goal file not found: #{@goal_file}"
    end

    unless File.exist?(@prompt_template)
      fatal "Prompt template not found: #{@prompt_template}"
    end

    unless File.exist?(@summarizer_template)
      fatal "Summarizer template not found: #{@summarizer_template}"
    end

    validate_goal_structure
  end

  def validate_goal_structure
    content = File.read(@goal_file)

    unless content =~ /^## Objective\s*$/m
      fatal "Goal file missing required section: ## Objective"
    end
  end

  def initialize_state
    File.write(@progress_file, '')
    File.write(@summary_file, '')
    File.write(@summary_meta_file, '{"covers_up_to": 0}')
    @iteration = 0
  end

  def load_state
    @iteration = count_progress_entries
  end

  def display_continue_status
    return unless @continue_run && @iteration.positive?

    puts "Continuing from iteration #{@iteration}"
    puts
  end

  def count_progress_entries
    return 0 unless File.exist?(@progress_file)

    File.readlines(@progress_file).count { |line| !line.strip.empty? }
  end

  def handle_dirty_state
    # Check if working copy has changes
    status = `jj status 2>/dev/null`.strip
    return if status.empty? || status.include?('working copy') && status.include?('no changes')

    # Working copy is dirty - commit and record as iteration
    @iteration += 1
    revision = `jj log -r @ --no-graph -T 'change_id.short()' 2>/dev/null`.strip

    progress = "Dirty working copy detected and committed, use `jj diff -r #{revision}` to see the changes."
    record_progress(progress)
    commit_iteration("dirty state recovery")

    # Display as proper iteration
    puts "\e[1mIteration #{@iteration}\e[0m"
    puts
    puts "#{progress}"
    puts

    summarize_if_needed
  end

  def create_bookmark_if_needed
    existing = `jj bookmark list --no-graph 2>/dev/null`.strip
    if existing.include?(@branch_name)
      log "Bookmark '#{@branch_name}' already exists"
      return
    end
    system("jj bookmark create #{@branch_name.shellescape} >/dev/null 2>&1")
    log "Created bookmark '#{@branch_name}' at current revision"
  end

  # ─────────────────────────────────────────────────────────────
  # Main Loop
  # ─────────────────────────────────────────────────────────────

  def run_iteration
    display_iteration_header

    prompt = build_worker_prompt
    iteration_start = Time.now
    start_spinner("Iteration #{@iteration}")

    result = invoke_claude(
      prompt: prompt,
      model: @model,
      thinking_budget: @thinking_budget,
      tools: 'Read,Write,Edit,Glob,Grep,Bash,Skill,StructuredOutput',
      schema: PROGRESS_SCHEMA,
      iteration_start: iteration_start
    )

    stop_spinner

    parsed = parse_progress(result)

    if parsed[:error]
      display_error("Failed to parse agent output: #{parsed[:error]}")
      error_msg = "ERROR: #{parsed[:error]}"
      error_msg += "\nRAW: #{parsed[:raw]}" if parsed[:raw]
      record_progress(error_msg)
      commit_iteration('error - parse failure')
      return nil
    end

    progress = parsed[:summary]
    display_progress(progress)
    record_progress(progress)
    commit_iteration(progress)

    progress == 'DONE' ? 'DONE' : nil
  end

  def summarize_if_needed
    entries_since_summary = count_entries_since_summary
    return unless entries_since_summary >= MAX_RECENT

    display_summarizing
    start_spinner('Summarizing')

    prompt = build_summarizer_prompt
    result = invoke_claude(
      prompt: prompt,
      model: 'haiku',
      thinking_budget: @summarizer_budget,
      tools: 'Read,Glob,Grep,StructuredOutput',
      schema: '{"type":"object","properties":{"summary":{"type":"string"}},"required":["summary"]}'
    )

    stop_spinner

    new_summary = parse_summary(result)
    if new_summary
      save_summary(new_summary)
      puts 'Summary updated'
      puts
    else
      puts 'Summary generation failed'
      puts
    end
  end

  # ─────────────────────────────────────────────────────────────
  # Prompt Building
  # ─────────────────────────────────────────────────────────────

  def build_worker_prompt
    goal = File.read(@goal_file)
    summary_content = load_summary
    summary_end = calculate_summary_end
    recent = build_recent_iterations

    render_template(@prompt_template, {
      goal: goal,
      summary_end: summary_end,
      summary: summary_content,
      recent: recent,
      skills: load_skills,
      advertised_skills: build_advertised_skills,
      pull_request: @pull_request,
      branch_name: @branch_name
    })
  end

  def build_summarizer_prompt
    summary_content = load_summary
    summary_end = calculate_summary_end
    total = count_progress_entries
    new_summary_end = calculate_fixed_coverage(total)
    recent = build_recent_iterations_for_summary(new_summary_end)

    render_template(@summarizer_template, {
      summary_end: summary_end,
      summary: summary_content,
      current: new_summary_end,
      recent: recent
    })
  end

  def render_template(template_file, vars)
    template = File.read(template_file)
    erb = ERB.new(template)
    erb.result_with_hash(vars)
  end

  def load_summary
    return 'No prior iterations.' unless File.exist?(@summary_file)

    content = File.read(@summary_file).strip
    content.empty? ? 'No prior iterations.' : content
  end

  def calculate_summary_end
    return 0 unless File.exist?(@summary_meta_file)

    meta = JSON.parse(File.read(@summary_meta_file))
    meta['covers_up_to'] || 0
  rescue StandardError
    0
  end

  def count_entries_since_summary
    total = count_progress_entries
    summary_end = calculate_summary_end
    total - summary_end
  end

  def calculate_fixed_coverage(total)
    # Round down to nearest multiple of SUMMARY_INTERVAL
    ((total - SUMMARY_INTERVAL) / SUMMARY_INTERVAL) * SUMMARY_INTERVAL
  end

  def build_recent_iterations
    return '' unless File.exist?(@progress_file)

    entries = load_progress_entries
    summary_end = calculate_summary_end

    # Get entries after summary (at most MAX_RECENT - 1; the 10th triggers summary)
    recent_entries = entries.drop(summary_end).take(MAX_RECENT - 1)

    recent_entries.each_with_index.map do |entry, idx|
      iteration_num = summary_end + idx + 1
      "### Iteration #{iteration_num}\n\n#{entry['progress']}"
    end.join("\n\n")
  end

  def build_recent_iterations_for_summary(new_summary_end)
    return '' unless File.exist?(@progress_file)

    entries = load_progress_entries
    summary_end = calculate_summary_end

    return '' if new_summary_end <= summary_end

    entries_to_summarize = entries[summary_end...new_summary_end]

    entries_to_summarize.each_with_index.map do |entry, idx|
      iteration_num = summary_end + idx + 1
      "### Iteration #{iteration_num}\n\n#{entry['progress']}"
    end.join("\n\n")
  end

  def load_progress_entries
    return [] unless File.exist?(@progress_file)

    File.readlines(@progress_file).map do |line|
      JSON.parse(line.strip)
    rescue JSON::ParserError
      nil
    end.compact
  end

  def load_skills
    # Load implementor skillset (excluding jj - ralph handles commits itself)
    skillset_file = '.claude/skillsets/implementor.json'
    skillset = JSON.parse(File.read(skillset_file))

    skills_to_load = skillset['preload'] - ['jj']

    skills_to_load.map do |skill_name|
      skill_file = ".claude/library/#{skill_name}/SKILL.md"
      content = File.read(skill_file)
      "## #{skill_name}\n\n#{content}"
    end.join("\n\n")
  end

  def build_advertised_skills
    # Advertise skills from developer that aren't in implementor (excluding jj)
    implementor = JSON.parse(File.read('.claude/skillsets/implementor.json'))['preload']
    developer = JSON.parse(File.read('.claude/skillsets/developer.json'))['preload']

    extra_skills = (developer - implementor) - ['jj']

    extra_skills.map do |skill_name|
      skill_file = ".claude/library/#{skill_name}/SKILL.md"
      next unless File.exist?(skill_file)

      # Extract description from YAML frontmatter
      content = File.read(skill_file)
      if content =~ /^description:\s*(.+)$/
        desc = $1.strip
        "| `#{skill_name}` | #{desc} |"
      end
    end.compact.join("\n")
  end

  # ─────────────────────────────────────────────────────────────
  # Claude Invocation
  # ─────────────────────────────────────────────────────────────

  def invoke_claude(prompt:, model:, thinking_budget:, tools:, schema:, iteration_start: nil)
    env = thinking_budget.positive? ? "MAX_THINKING_TOKENS=#{thinking_budget} " : ''
    cmd = "#{env}ANTHROPIC_API_KEY= claude -p --model #{model} --tools \"#{tools}\" --verbose --input-format stream-json --output-format stream-json --json-schema '#{schema}' 2>/dev/null"

    result = nil
    tool_names = {}  # track tool_use_id -> tool_name for result lookup
    counters = { assistant_messages: 0, tool_uses: 0, llm_time: 0.0, tool_time: 0.0 }

    start_waiting_timer(iteration_start) if iteration_start
    IO.popen(cmd, 'r+') do |io|
      # Send initial prompt via stdin
      initial_message = {
        type: 'user',
        message: {
          role: 'user',
          content: [{ type: 'text', text: prompt }]
        }
      }
      io.puts(initial_message.to_json)
      io.flush
      debug("sent initial prompt (#{prompt.length} chars)")

      # First attempt to read result
      result = read_until_result(io, tool_names, iteration_start, model, counters)

      # Retry logic for invalid structured output
      retry_count = 0
      max_retries = 3
      last_error = nil

      while result && retry_count < max_retries
        parsed = parse_progress_result(result)

        if parsed[:error]
          # Send correction message
          retry_count += 1
          last_error = parsed[:error]
          correction = build_correction_message(parsed[:error])
          io.puts(correction)
          io.flush

          # Read next result
          result = read_until_result(io, tool_names, iteration_start, model, counters)
        else
          # Valid result, exit retry loop
          break
        end
      end

      # Check if retries exhausted
      if result && retry_count >= max_retries
        parsed = parse_progress_result(result)
        if parsed[:error]
          # Retries exhausted - create error result
          result = {
            'structured_output' => {
              'summary' => "ERROR: Failed to parse structured output after #{max_retries} retries. Last error: #{last_error}"
            }
          }
        end
      end

      # Close write end after valid result or exhausted retries
      io.close_write
    end
      stop_waiting_timer if iteration_start

      # Update running totals
      if iteration_start
        @total_assistant_messages += counters[:assistant_messages]
        @total_tool_uses += counters[:tool_uses]
        @total_llm_time += counters[:llm_time]
        @total_tool_time += counters[:tool_time]
      end

      result&.to_json
  end

  def read_until_result(io, tool_names, iteration_start, model, counters)
    result = nil
    last_event_time = Time.now

    io.each_line do |line|
      event = JSON.parse(line) rescue next
      debug("event type: #{event['type']}")
      case event['type']
      when 'assistant'
        counters[:llm_time] += (Time.now - last_event_time)
        last_event_time = Time.now
        counters[:assistant_messages] += 1
        context_pct = extract_context_percentage(event)
        text = extract_text_content(event)
        output_message(text, iteration_start, context_pct) unless text.empty?
        tool_use_list = extract_tool_uses(event)
        counters[:tool_uses] += tool_use_list.length
        tool_use_list.each do |tool_use|
          tool_names[tool_use['id']] = tool_use['name']
          output_tool_use(tool_use, iteration_start)
        end
        # Track tokens from usage
        track_usage(event, model) if iteration_start
      when 'user'
        counters[:tool_time] += (Time.now - last_event_time)
        last_event_time = Time.now
        # Tool results only - user text messages don't appear in this context
        extract_tool_results(event).each do |tool_result|
          name = tool_names[tool_result['tool_use_id']] || 'unknown'
          output_tool_result(name, tool_result, event['tool_use_result'], iteration_start)
        end
      when 'result'
        result = event
        break
      else
        # Unknown message type - output in subdued style
        reset_waiting_timer
        suffix = format_timing_suffix
        puts "\e[90m? #{event['type']} #{suffix}\e[0m"
        puts
      end
    end

    result
  end

  def parse_progress_result(result)
    return { error: 'no structured_output' } if result.nil?

    structured = result['structured_output']
    if structured.nil?
      return { error: 'no structured_output' }
    end

    summary = structured['summary']
    if summary.nil?
      return { error: 'no summary field' }
    end

    { summary: summary }
  end

  def build_correction_message(error_type)
    correction_text = case error_type
    when 'no structured_output'
      'You must use the StructuredOutput tool. Return: {"summary": "what you accomplished"}'
    when 'no summary field'
      'Missing "summary" field. Return: {"summary": "what you accomplished"}'
    else
      'Invalid output. Use StructuredOutput tool: {"summary": "what you accomplished"}'
    end

    {
      type: 'user',
      message: {
        role: 'user',
        content: [
          {
            type: 'text',
            text: correction_text
          }
        ]
      }
    }.to_json
  end

  def track_usage(event, model)
    usage = event.dig('message', 'usage')
    return unless usage

    input = usage['input_tokens'] || 0
    output = usage['output_tokens'] || 0
    cache_read = usage['cache_read_input_tokens'] || 0
    cache_create = usage['cache_creation_input_tokens'] || 0

    @total_tokens[:input] += input
    @total_tokens[:output] += output
    @total_tokens[:cache_read] += cache_read
    @total_tokens[:cache_create] += cache_create

    # Calculate cost
    pricing = MODEL_PRICING[model]
    return unless pricing

    cost = (input * pricing[:input] / 1_000_000.0) +
           (output * pricing[:output] / 1_000_000.0) +
           (cache_read * pricing[:cache_read] / 1_000_000.0) +
           (cache_create * pricing[:cache_create] / 1_000_000.0)

    @total_cost += cost
  end

  def format_timing_suffix(context_pct = nil)
    now = Time.now
    delta = format_elapsed((now - @last_output_time).to_i)
    total = format_elapsed((now - @start_time).to_i)
    @last_output_time = now

    if context_pct
      "(+#{delta} / #{total}) [#{context_pct}%]"
    else
      "(+#{delta} / #{total})"
    end
  end

  def output_message(text, iteration_start, context_pct = nil)
    reset_waiting_timer
    maybe_ralph_says
    suffix = "\e[90m#{format_timing_suffix(context_pct)}\e[0m"
    lines = text.lines
    if lines.empty?
      puts suffix
    elsif lines.length == 1
      puts "#{lines.first.chomp} #{suffix}"
    else
      puts lines.first
      lines[1...-1].each { |l| puts l }
      puts "#{lines.last.chomp} #{suffix}"
    end
    puts
  end

  def output_tool_use(tool_use, iteration_start)
    reset_waiting_timer
    suffix = format_timing_suffix
    name = tool_use['name']
    params = format_params(tool_use['input'] || {})
    puts "\e[90m→ #{name} #{params} #{suffix}\e[0m"
    puts
  end

  def output_tool_result(name, tool_result, tool_use_result, iteration_start)
    reset_waiting_timer
    suffix = format_timing_suffix
    # Prefer structured tool_use_result, fall back to content
    data = tool_use_result || { 'content' => tool_result['content'] }
    params = format_params(data)
    puts "\e[90m← #{name} #{params} #{suffix}\e[0m"
    puts
  end

  def format_params(hash)
    return '' unless hash.is_a?(Hash)

    hash.map do |k, v|
      val = v.is_a?(Hash) || v.is_a?(Array) ? v.to_json : v.to_s
      val = val.gsub(/\s+/, ' ').strip
      val = val[0, 45] + '...' if val.length > 48
      val = "\"#{val}\"" if val.include?(' ')
      "#{k}=#{val}"
    end.join(', ')
  end

  def extract_text_content(event)
    content = event.dig('message', 'content') || []
    content
      .select { |b| b['type'] == 'text' }
      .map { |b| b['text'] }
      .join
  end

  def extract_tool_uses(event)
    content = event.dig('message', 'content') || []
    content.select { |b| b['type'] == 'tool_use' }
  end

  def extract_tool_results(event)
    content = event.dig('message', 'content') || []
    content.select { |b| b['type'] == 'tool_result' }
  end

  def extract_context_percentage(event)
    usage = event.dig('message', 'usage')
    return nil unless usage

    input = usage['input_tokens'] || 0
    cache_create = usage['cache_creation_input_tokens'] || 0
    cache_read = usage['cache_read_input_tokens'] || 0
    total_context = input + cache_create + cache_read

    return nil if total_context.zero?

    ((total_context.to_f / 200_000) * 100).round(1)
  end

  def with_temp_file(content)
    temp = Tempfile.new(['ralph-prompt', '.md'])
    temp.write(content)
    temp.close
    yield temp.path
  ensure
    temp&.unlink
  end

  def parse_progress(result)
    return { error: 'nil result', raw: nil } if result.nil?

    parsed = JSON.parse(result, symbolize_names: true)
    structured = parsed[:structured_output]

    if structured.nil?
      return { error: 'no structured_output', raw: result[0, 500] }
    end

    summary = structured[:summary]
    if summary.nil?
      return { error: 'no summary field', raw: result[0, 500] }
    end

    { summary: summary }
  rescue JSON::ParserError => e
    { error: "JSON parse error: #{e.message}", raw: result&.[](0, 500) }
  end

  def parse_summary(result)
    parsed = JSON.parse(result, symbolize_names: true)
    structured = parsed[:structured_output]
    return nil if structured.nil?

    structured[:summary]
  rescue JSON::ParserError
    nil
  end

  # ─────────────────────────────────────────────────────────────
  # State Management
  # ─────────────────────────────────────────────────────────────

  def record_progress(progress)
    entry = {
      iteration: @iteration,
      timestamp: Time.now.iso8601,
      progress: progress
    }
    File.open(@progress_file, 'a') { |f| f.puts(entry.to_json) }
  end

  def save_summary(summary)
    File.write(@summary_file, summary)

    # Update metadata with new coverage (fixed intervals)
    total = count_progress_entries
    new_coverage = calculate_fixed_coverage(total)
    File.write(@summary_meta_file, JSON.generate({ 'covers_up_to' => new_coverage }))
  end

  def commit_iteration(progress)
    # Truncate progress for commit message
    short_progress = progress.to_s[0, 200]
    short_progress += '...' if progress.to_s.length > 200

    msg = <<~MSG
      ralph: iteration #{@iteration}

      #{short_progress}
    MSG

    system("jj commit -m #{msg.shellescape} >/dev/null 2>&1")
  end

  # ─────────────────────────────────────────────────────────────
  # Display
  # ─────────────────────────────────────────────────────────────

  def display_header
    duration_str = @duration_seconds == Float::INFINITY ? 'unlimited' : format_elapsed(@duration_seconds.to_i)
    unless @no_art
      ascii_file = File.join(SCRIPT_DIR, 'ralph.ascii')
      if File.exist?(ascii_file)
        print File.read(ascii_file).chomp
        puts '─' * 70
        puts
      end
    end
    puts "\e[1mRALPH v#{VERSION}\e[0m"
    puts
    puts "Braindead agentic loop. Just keep trying until it works."
    puts
    puts "\e[1mParams\e[0m"
    puts
    puts "Model: #{@model} | Reasoning: #{@reasoning} | Max Duration: #{duration_str}"
    puts
  end

  def display_goal
    goal_content = File.read(@goal_file)

    # Extract just the objective section
    objective = extract_objective(goal_content)

    puts "\e[1mGoal\e[0m"
    puts
    puts objective
    puts
  end

  def extract_objective(content)
    # Try to extract ## Objective section
    if content =~ /^## Objective\s*\n(.*?)(?=\n##|\z)/m
      return $1.strip
    end

    # Fallback: first 500 chars
    content[0, 500]
  end

  def display_iteration_header
    puts "\e[1mIteration #{@iteration}\e[0m"
    puts
  end

  def maybe_ralph_says
    return if @no_quotes
    return unless rand < 0.03  # 3% chance

    puts "\e[33mRalph:\e[0m #{RALPH_QUOTES.sample}"
    puts
  end

  def display_progress(progress)
    puts
    if progress == 'DONE'
      puts "\e[32m✓ DONE\e[0m"
    else
      # Word wrap and indent
      wrapped = word_wrap(progress, 66)
      wrapped.each_line do |line|
        puts "  #{line}"
      end
      puts
      puts '─' * 70
    end
  end

  def display_error(message)
    puts
    puts "\e[31m  ✗ #{message}\e[0m"
    puts
    puts '─' * 70
  end

  def display_summarizing
    puts "\e[33mSummarizing progress (every #{MAX_RECENT} iterations)...\e[0m"
    puts
    $stdout.flush
  end

  def display_summary
    @total_iterations = @iteration
    actual_elapsed = (Time.now - @start_time).to_i
    elapsed = format_elapsed(actual_elapsed)

    puts
    puts "\e[1m" + '═' * 70 + "\e[0m"
    puts "  Iterations: #{@total_iterations}"
    puts "  Assistant Messages: #{@total_assistant_messages}"
    puts "  Tool Uses: #{@total_tool_uses}"
    puts

    puts "  Tokens:"
    puts "    Input: #{format_number(@total_tokens[:input])}"
    puts "    Output: #{format_number(@total_tokens[:output])}"
    puts "    Cache Read: #{format_number(@total_tokens[:cache_read])}"
    puts "    Cache Create: #{format_number(@total_tokens[:cache_create])}"
    total_tokens = @total_tokens.values.sum
    puts "    Total: #{format_number(total_tokens)}"
    puts

    puts "  Cost: $#{format('%.4f', @total_cost)}"
    puts
    other_time = [actual_elapsed - @total_llm_time - @total_tool_time, 0].max
    puts "  Time:"
    puts "    LLM: #{format_elapsed(@total_llm_time.to_i)}"
    puts "    Tools: #{format_elapsed(@total_tool_time.to_i)}"
    puts "    Other: #{format_elapsed(other_time.to_i)}"
    puts "    Total: #{elapsed}"

    puts "\e[1m" + '═' * 70 + "\e[0m"
    puts

    write_stats_record(actual_elapsed)
  end

  def format_number(num)
    num.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
  end

  def word_wrap(text, width)
    text.gsub(/(.{1,#{width}})(\s+|$)/, "\\1\n").strip
  end

  # ─────────────────────────────────────────────────────────────
  # Notifications
  # ─────────────────────────────────────────────────────────────

  def notify_enabled?
    ENV['NTFY_TOPIC'] && ENV['NTFY_API_KEY']
  end

  def send_notification
    return unless notify_enabled?

    elapsed = format_elapsed((Time.now - @start_time).to_i)
    goal_name = File.basename(@goal_file, '.*').sub(/-goal$/, '')

    case @exit_reason
    when :done
      title = "Ralph: #{goal_name} complete"
      message = "Goal achieved in #{@iteration} iterations (#{elapsed})"
    when :timeout
      title = "Ralph: #{goal_name} timeout"
      message = "Time budget expired after #{@iteration} iterations (#{elapsed})"
    when :interrupted
      title = "Ralph: #{goal_name} interrupted"
      message = "Stopped at iteration #{@iteration} (#{elapsed})"
    else
      title = "Ralph: #{goal_name} exited"
      message = "Exited after #{@iteration} iterations (#{elapsed})"
    end

    notify_script = File.join(SCRIPT_DIR, '..', '..', 'scripts', 'notify')
    payload = { title: title, message: message }.to_json

    IO.popen(notify_script, 'r+') do |io|
      io.write(payload)
      io.close_write
      io.read  # consume output
    end
  rescue StandardError => e
    # Notification failure is non-fatal
    $stderr.puts "\e[33mNotification failed: #{e.message}\e[0m"
  end

  # ─────────────────────────────────────────────────────────────
  # Stats Logging
  # ─────────────────────────────────────────────────────────────

  def ensure_state_dirs
    FileUtils.mkdir_p(STATE_DIR)
    FileUtils.mkdir_p(GOALS_DIR)
  end

  def copy_goal_file
    ensure_state_dirs
    # Append datetime to filename: feature-goal.md -> feature-goal-2026-01-30T14-30-00.md
    base = File.basename(@goal_file, '.*')
    ext = File.extname(@goal_file)
    timestamp = @start_time.strftime('%Y-%m-%dT%H-%M-%S')
    @goal_copy_name = "#{base}-#{timestamp}#{ext}"
    dest = File.join(GOALS_DIR, @goal_copy_name)
    FileUtils.cp(@goal_file, dest)
  end

  def write_stats_record(actual_elapsed)
    ensure_state_dirs

    other_time = [actual_elapsed - @total_llm_time - @total_tool_time, 0].max

    record = {
      goal_file: "goals/#{@goal_copy_name}",
      started_at: @start_time.iso8601,
      exit_reason: @exit_reason.to_s,
      model: @model,
      reasoning: @reasoning,
      iterations: @total_iterations,
      assistant_messages: @total_assistant_messages,
      tool_uses: @total_tool_uses,
      tokens: {
        input: @total_tokens[:input],
        output: @total_tokens[:output],
        cache_read: @total_tokens[:cache_read],
        cache_create: @total_tokens[:cache_create]
      },
      cost_usd: @total_cost,
      time_seconds: {
        llm: @total_llm_time.to_i,
        tools: @total_tool_time.to_i,
        other: other_time.to_i,
        total: actual_elapsed
      }
    }

    File.open(STATS_FILE, 'a') { |f| f.puts(record.to_json) }
  end

  # ─────────────────────────────────────────────────────────────
  # Utilities
  # ─────────────────────────────────────────────────────────────

  def log(message)
    timestamp = Time.now.strftime('%H:%M:%S')
    puts "  \e[90m[#{timestamp}]\e[0m #{message}"
  end

  def debug(message)
    return unless @debug

    $stderr.puts "\e[33m[DEBUG] #{message}\e[0m"
  end

  def fatal(message)
    $stderr.puts "\e[31mError: #{message}\e[0m"
    exit 1
  end

  def parse_duration(duration_str)
    return Float::INFINITY if duration_str.nil?

    value = duration_str.to_i
    unit = duration_str[-1]

    case unit
    when 'h' then value * 3600
    when 'm' then value * 60
    else value
    end
  end

  def format_elapsed(seconds)
    hours, remainder = seconds.divmod(3600)
    mins, secs = remainder.divmod(60)

    if hours > 0
      "#{hours}h #{mins}m #{secs}s"
    elsif mins > 0
      "#{mins}m #{secs}s"
    else
      "#{secs}s"
    end
  end

  def time_expired?
    return false if @duration_seconds == Float::INFINITY

    elapsed = Time.now - @start_time
    if elapsed >= @duration_seconds
      log "Time budget expired"
      true
    else
      false
    end
  end

  def calculate_thinking_budget(model, reasoning)
    max_budget = MAX_THINKING_BUDGET[model] || 32_000
    multiplier = REASONING_MULTIPLIERS[reasoning] || 0.25
    (max_budget * multiplier).to_i
  end

  # ─────────────────────────────────────────────────────────────
  # Spinner
  # ─────────────────────────────────────────────────────────────

  def start_spinner(message)
    return if @no_spinner

    @spinner_running = true
    start = Time.now

    @spinner_thread = Thread.new do
      idx = 0
      while @spinner_running
        elapsed = (Time.now - start).to_i
        mins, secs = elapsed.divmod(60)
        frame = SPINNER_FRAMES[idx % SPINNER_FRAMES.length]
        print "\r  #{frame} #{message} [#{format('%02d:%02d', mins, secs)}]"
        $stdout.flush
        idx += 1
        sleep 0.1
      end
      print "\r#{' ' * 60}\r"
      $stdout.flush
    end
  end

  def stop_spinner
    return if @no_spinner

    @spinner_running = false
    @spinner_thread&.join(1)
  end

  # ─────────────────────────────────────────────────────────────
  # Waiting Timer
  # ─────────────────────────────────────────────────────────────

  def start_waiting_timer(iteration_start)
    @waiting_timer_running = true
    @waiting_timer_displayed = false
    @last_output_time = Time.now

    @waiting_timer_thread = Thread.new do
      while @waiting_timer_running
        since_output = Time.now - @last_output_time
        if since_output >= 5.0
          @waiting_timer_displayed = true
          elapsed = format_elapsed(since_output.to_i)
          print "\rthinking (+#{elapsed})"
          $stdout.flush
        end
        sleep 0.1
      end
    end
  end

  def stop_waiting_timer
    @waiting_timer_running = false
    @waiting_timer_thread&.join(1)
    clear_waiting_timer
  end

  def reset_waiting_timer
    return unless @waiting_timer_running

    @last_output_time = Time.now
    clear_waiting_timer
  end

  def clear_waiting_timer
    return unless @waiting_timer_displayed

    print "\r#{' ' * 30}\r"
    $stdout.flush
    @waiting_timer_displayed = false
  end
end

# ─────────────────────────────────────────────────────────────
# CLI
# ─────────────────────────────────────────────────────────────

options = {
  model: 'sonnet',
  reasoning: 'med',
  no_spinner: true,
  no_art: false,
  no_quotes: false,
  continue: false,
  debug: false,
  pull_request: true
}

OptionParser.new do |opts|
  opts.banner = <<~BANNER
    Ralph - Braindead agentic loop. Just keep trying until it works.

    Usage: ralph --goal=FILE [--duration=4h] [options]
  BANNER

  opts.on('--goal=FILE', 'Goal markdown file (required)') do |f|
    options[:goal] = f
  end

  opts.on('--duration=DURATION', 'Time budget (e.g., 4h, 200m)') do |d|
    options[:duration] = d
  end

  opts.on('--model=MODEL', %w[haiku sonnet opus], 'Model: haiku, sonnet, opus (default: sonnet)') do |m|
    options[:model] = m
  end

  opts.on('--reasoning=LEVEL', %w[none low med high], 'Reasoning: none, low, med, high (default: med)') do |r|
    options[:reasoning] = r
  end

  opts.on('--spinner', 'Enable progress spinner (off by default)') do
    options[:no_spinner] = false
  end

  opts.on('--continue', 'Continue from existing progress') do
    options[:continue] = true
  end

  opts.on('--no-art', 'Suppress ASCII art in header') do
    options[:no_art] = true
  end

  opts.on('--no-quotes', 'Disable Ralph quotes') do
    options[:no_quotes] = true
  end

  opts.on('--debug', 'Enable debug output') do
    options[:debug] = true
  end

  opts.on('--[no-]pull-request', 'Create pull request when goal complete (default: enabled)') do |pr|
    options[:pull_request] = pr
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end

  opts.on('-v', '--version', 'Show version') do
    puts "ralph #{Ralph::VERSION}"
    exit
  end
end.parse!

if options[:goal].nil?
  $stderr.puts 'Error: --goal=FILE is required'
  $stderr.puts 'Usage: ralph --goal=FILE [--duration=4h] [options]'
  exit 1
end

ralph = Ralph.new(
  goal_file: options[:goal],
  duration: options[:duration],
  model: options[:model],
  reasoning: options[:reasoning],
  no_spinner: options[:no_spinner],
  no_art: options[:no_art],
  no_quotes: options[:no_quotes],
  continue_run: options[:continue],
  debug: options[:debug],
  pull_request: options[:pull_request]
)

begin
  ralph.run
rescue Interrupt
  ralph.interrupt!
  puts "\n\nInterrupted"
  exit 130
end

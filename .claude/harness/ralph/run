#!/usr/bin/env ruby
# frozen_string_literal: true

# TODO: Track running totals across all iterations and report at completion:
#   - Total iteration count
#   - Total assistant messages count
#   - Total tool uses count
#   - Total tokens (input, output, cache_read, cache_create)
#   - Total dollars spent (calculate from token counts and model pricing)
#   - Total elapsed time
# Display in display_summary().

# TODO: Add '--no-quotes' flag to disable Ralph quotes in maybe_ralph_says().

# TODO: Support multiple goal files via --goal=FILE1,FILE2,FILE3
#   - Process each goal file sequentially
#   - Reset progress/summary files when transitioning to next goal
#   - Keep running totals (iterations, tokens, cost, time) across all goals
#   - Report aggregate stats at completion

require 'json'
require 'optparse'
require 'shellwords'
require 'time'
require 'erb'
require 'tempfile'

# Resolve script directory at load time (before any chdir)
SCRIPT_DIR = File.dirname(File.realpath(__FILE__))

# Ralph: Iterative goal completion harness
class Ralph
  VERSION = '0.2.0'

  SUMMARY_INTERVAL = 5
  MAX_RECENT = 10

  SPINNER_FRAMES = %w[⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏].freeze

  PROGRESS_SCHEMA = '{"type":"object","properties":{"progress":{"type":"string"}},"required":["progress"]}'

  MAX_THINKING_BUDGET = {
    'haiku' => 16_384,
    'sonnet' => 32_768,
    'opus' => 16_384
  }.freeze

  REASONING_MULTIPLIERS = {
    'none' => 0.0,
    'low' => 0.25,
    'med' => 0.5,
    'high' => 1.0
  }.freeze

  RALPH_QUOTES = [
    "Me fail English? That's unpossible!",
    "I choo-choo-choose you!",
    "Hi, Super Nintendo Chalmers!",
    "I'm in danger!",
    "My cat's breath smells like cat food.",
    "I bent my Wookie.",
    "I ate the blue ones... they taste like burning.",
    "He told me to burn things.",
    "When I grow up I wanna be a principal or a caterpillar.",
    "Go banana!"
  ].freeze

  def initialize(goal_file:, duration:, model:, reasoning:, no_spinner:, no_art:, continue_run:)
    @goal_file = goal_file
    @duration_seconds = parse_duration(duration)
    @model = model
    @reasoning = reasoning
    @thinking_budget = calculate_thinking_budget(model, reasoning)
    @summarizer_budget = calculate_thinking_budget('haiku', 'high')
    @no_spinner = no_spinner
    @no_art = no_art
    @continue_run = continue_run

    @start_time = Time.now
    @iteration = 0
    @spinner_thread = nil
    @spinner_running = false
    @waiting_timer_thread = nil
    @waiting_timer_running = false
    @waiting_timer_displayed = false
    @last_output_time = Time.now

    # Derive state file paths from goal file
    base = @goal_file.sub(/-goal\.md$/, '').sub(/\.md$/, '')
    @progress_file = "#{base}-progress.jsonl"
    @summary_file = "#{base}-summary.md"
    @summary_meta_file = "#{base}-summary-meta.json"

    # Prompt templates
    @prompt_template = File.join(SCRIPT_DIR, 'prompt.md')
    @summarizer_template = File.join(SCRIPT_DIR, 'summarizer.md')
  end

  def run
    validate_files
    initialize_state unless @continue_run
    load_state if @continue_run

    display_header
    display_goal
    sleep 2
    display_continue_status
    handle_dirty_state
    summarize_if_needed if @continue_run

    @exit_reason = nil
    loop do
      if time_expired?
        @exit_reason = :timeout
        break
      end

      @iteration += 1
      result = run_iteration

      if result == 'DONE'
        @exit_reason = :done
        break
      end

      summarize_if_needed
    end

    display_summary
    send_notification
  end

  def interrupt!
    @exit_reason = :interrupted
    send_notification
  end

  private

  # ─────────────────────────────────────────────────────────────
  # Setup & State
  # ─────────────────────────────────────────────────────────────

  def validate_files
    unless File.exist?(@goal_file)
      fatal "Goal file not found: #{@goal_file}"
    end

    unless File.exist?(@prompt_template)
      fatal "Prompt template not found: #{@prompt_template}"
    end

    unless File.exist?(@summarizer_template)
      fatal "Summarizer template not found: #{@summarizer_template}"
    end

    validate_goal_structure
  end

  def validate_goal_structure
    content = File.read(@goal_file)

    unless content =~ /^## Objective\s*$/m
      fatal "Goal file missing required section: ## Objective"
    end
  end

  def initialize_state
    File.write(@progress_file, '')
    File.write(@summary_file, '')
    File.write(@summary_meta_file, '{"covers_up_to": 0}')
    @iteration = 0
  end

  def load_state
    @iteration = count_progress_entries
  end

  def display_continue_status
    return unless @continue_run && @iteration.positive?

    puts "Continuing from iteration #{@iteration}"
    puts
  end

  def count_progress_entries
    return 0 unless File.exist?(@progress_file)

    File.readlines(@progress_file).count { |line| !line.strip.empty? }
  end

  def handle_dirty_state
    # Check if working copy has changes
    status = `jj status 2>/dev/null`.strip
    return if status.empty? || status.include?('working copy') && status.include?('no changes')

    # Working copy is dirty - commit and record as iteration
    @iteration += 1
    revision = `jj log -r @ --no-graph -T 'change_id.short()' 2>/dev/null`.strip

    progress = "Dirty working copy detected and committed, use `jj diff -r #{revision}` to see the changes."
    record_progress(progress)
    commit_iteration("dirty state recovery")

    # Display as proper iteration
    puts "\e[1mIteration #{@iteration}\e[0m"
    puts
    puts "#{progress}"
    puts

    summarize_if_needed
  end

  # ─────────────────────────────────────────────────────────────
  # Main Loop
  # ─────────────────────────────────────────────────────────────

  def run_iteration
    display_iteration_header

    prompt = build_worker_prompt
    iteration_start = Time.now
    start_spinner("Iteration #{@iteration}")

    result = invoke_claude(
      prompt: prompt,
      model: @model,
      thinking_budget: @thinking_budget,
      tools: 'Read,Write,Edit,Glob,Grep,Bash,Skill,StructuredOutput',
      schema: PROGRESS_SCHEMA,
      iteration_start: iteration_start
    )

    stop_spinner

    parsed = parse_progress(result)

    if parsed[:error]
      display_error("Failed to parse agent output: #{parsed[:error]}")
      error_msg = "ERROR: #{parsed[:error]}"
      error_msg += "\nRAW: #{parsed[:raw]}" if parsed[:raw]
      record_progress(error_msg)
      commit_iteration('error - parse failure')
      return nil
    end

    progress = parsed[:progress]
    display_progress(progress)
    record_progress(progress)
    commit_iteration(progress)

    progress == 'DONE' ? 'DONE' : nil
  end

  def summarize_if_needed
    entries_since_summary = count_entries_since_summary
    return unless entries_since_summary >= MAX_RECENT

    display_summarizing
    start_spinner('Summarizing')

    prompt = build_summarizer_prompt
    result = invoke_claude(
      prompt: prompt,
      model: 'haiku',
      thinking_budget: @summarizer_budget,
      tools: 'StructuredOutput',
      schema: '{"type":"object","properties":{"summary":{"type":"string"}},"required":["summary"]}'
    )

    stop_spinner

    new_summary = parse_summary(result)
    if new_summary
      save_summary(new_summary)
      puts 'Summary updated'
      puts
    else
      puts 'Summary generation failed'
      puts
    end
  end

  # ─────────────────────────────────────────────────────────────
  # Prompt Building
  # ─────────────────────────────────────────────────────────────

  def build_worker_prompt
    goal = File.read(@goal_file)
    summary_content = load_summary
    summary_end = calculate_summary_end
    recent = build_recent_iterations

    render_template(@prompt_template, {
      goal: goal,
      summary_end: summary_end,
      summary: summary_content,
      recent: recent,
      skills: load_skills,
      advertised_skills: build_advertised_skills
    })
  end

  def build_summarizer_prompt
    summary_content = load_summary
    summary_end = calculate_summary_end
    total = count_progress_entries
    new_summary_end = total - SUMMARY_INTERVAL
    recent = build_recent_iterations_for_summary

    render_template(@summarizer_template, {
      summary_end: summary_end,
      summary: summary_content,
      current: new_summary_end,
      recent: recent
    })
  end

  def render_template(template_file, vars)
    template = File.read(template_file)
    erb = ERB.new(template)
    erb.result_with_hash(vars)
  end

  def load_summary
    return 'No prior iterations.' unless File.exist?(@summary_file)

    content = File.read(@summary_file).strip
    content.empty? ? 'No prior iterations.' : content
  end

  def calculate_summary_end
    return 0 unless File.exist?(@summary_meta_file)

    meta = JSON.parse(File.read(@summary_meta_file))
    meta['covers_up_to'] || 0
  rescue StandardError
    0
  end

  def count_entries_since_summary
    total = count_progress_entries
    summary_end = calculate_summary_end
    total - summary_end
  end

  def build_recent_iterations
    return '' unless File.exist?(@progress_file)

    entries = load_progress_entries
    summary_end = calculate_summary_end

    # Get entries after summary
    recent_entries = entries.drop(summary_end).take(MAX_RECENT)

    recent_entries.each_with_index.map do |entry, idx|
      iteration_num = summary_end + idx + 1
      "### Iteration #{iteration_num}\n\n#{entry['progress']}"
    end.join("\n\n")
  end

  def build_recent_iterations_for_summary
    return '' unless File.exist?(@progress_file)

    entries = load_progress_entries
    total = entries.length
    summary_end = calculate_summary_end

    # Only summarize up to (total - SUMMARY_INTERVAL)
    # This leaves the most recent SUMMARY_INTERVAL entries raw
    new_summary_end = total - SUMMARY_INTERVAL
    return '' if new_summary_end <= summary_end

    entries_to_summarize = entries[summary_end...new_summary_end]

    entries_to_summarize.each_with_index.map do |entry, idx|
      iteration_num = summary_end + idx + 1
      "### Iteration #{iteration_num}\n\n#{entry['progress']}"
    end.join("\n\n")
  end

  def load_progress_entries
    return [] unless File.exist?(@progress_file)

    File.readlines(@progress_file).map do |line|
      JSON.parse(line.strip)
    rescue JSON::ParserError
      nil
    end.compact
  end

  def load_skills
    # Load implementor skillset (excluding jj - ralph handles commits itself)
    skillset_file = '.claude/skillsets/implementor.json'
    skillset = JSON.parse(File.read(skillset_file))

    skills_to_load = skillset['preload'] - ['jj']

    skills_to_load.map do |skill_name|
      skill_file = ".claude/library/#{skill_name}/SKILL.md"
      content = File.read(skill_file)
      "## #{skill_name}\n\n#{content}"
    end.join("\n\n")
  end

  def build_advertised_skills
    # Advertise skills from developer that aren't in implementor (excluding jj)
    implementor = JSON.parse(File.read('.claude/skillsets/implementor.json'))['preload']
    developer = JSON.parse(File.read('.claude/skillsets/developer.json'))['preload']

    extra_skills = (developer - implementor) - ['jj']

    extra_skills.map do |skill_name|
      skill_file = ".claude/library/#{skill_name}/SKILL.md"
      next unless File.exist?(skill_file)

      # Extract description from YAML frontmatter
      content = File.read(skill_file)
      if content =~ /^description:\s*(.+)$/
        desc = $1.strip
        "| `#{skill_name}` | #{desc} |"
      end
    end.compact.join("\n")
  end

  # ─────────────────────────────────────────────────────────────
  # Claude Invocation
  # ─────────────────────────────────────────────────────────────

  def invoke_claude(prompt:, model:, thinking_budget:, tools:, schema:, iteration_start: nil)
    with_temp_file(prompt) do |prompt_file|
      env = thinking_budget.positive? ? "MAX_THINKING_TOKENS=#{thinking_budget} " : ''
      cmd = "#{env}claude -p #{prompt_file} --model #{model} --tools \"#{tools}\" --verbose --output-format stream-json --json-schema '#{schema}' 2>/dev/null"

      result = nil
      tool_names = {}  # track tool_use_id -> tool_name for result lookup

      start_waiting_timer(iteration_start) if iteration_start
      IO.popen(cmd, 'r') do |io|
        io.each_line do |line|
          event = JSON.parse(line) rescue next
          case event['type']
          when 'assistant'
            context_pct = extract_context_percentage(event)
            text = extract_text_content(event)
            output_message(text, iteration_start, context_pct) unless text.empty?
            extract_tool_uses(event).each do |tool_use|
              tool_names[tool_use['id']] = tool_use['name']
              output_tool_use(tool_use, iteration_start)
            end
          when 'user'
            # Tool results only - user text messages don't appear in this context
            extract_tool_results(event).each do |tool_result|
              name = tool_names[tool_result['tool_use_id']] || 'unknown'
              output_tool_result(name, tool_result, event['tool_use_result'], iteration_start)
            end
          when 'result'
            result = event
          end
        end
      end
      stop_waiting_timer if iteration_start
      result&.to_json
    end
  end

  def format_timing_suffix(context_pct = nil)
    now = Time.now
    delta = format_elapsed((now - @last_output_time).to_i)
    total = format_elapsed((now - @start_time).to_i)
    @last_output_time = now

    if context_pct
      "(+#{delta} / #{total}) [#{context_pct}%]"
    else
      "(+#{delta} / #{total})"
    end
  end

  def output_message(text, iteration_start, context_pct = nil)
    reset_waiting_timer
    maybe_ralph_says
    suffix = "\e[90m#{format_timing_suffix(context_pct)}\e[0m"
    lines = text.lines
    if lines.empty?
      puts suffix
    elsif lines.length == 1
      puts "#{lines.first.chomp} #{suffix}"
    else
      puts lines.first
      lines[1...-1].each { |l| puts l }
      puts "#{lines.last.chomp} #{suffix}"
    end
    puts
  end

  def output_tool_use(tool_use, iteration_start)
    reset_waiting_timer
    suffix = format_timing_suffix
    name = tool_use['name']
    params = format_params(tool_use['input'] || {})
    puts "\e[90m→ #{name} #{params} #{suffix}\e[0m"
    puts
  end

  def output_tool_result(name, tool_result, tool_use_result, iteration_start)
    reset_waiting_timer
    suffix = format_timing_suffix
    # Prefer structured tool_use_result, fall back to content
    data = tool_use_result || { 'content' => tool_result['content'] }
    params = format_params(data)
    puts "\e[90m← #{name} #{params} #{suffix}\e[0m"
    puts
  end

  def format_params(hash)
    return '' unless hash.is_a?(Hash)

    hash.map do |k, v|
      val = v.is_a?(Hash) || v.is_a?(Array) ? v.to_json : v.to_s
      val = val.gsub(/\s+/, ' ').strip
      val = val[0, 45] + '...' if val.length > 48
      val = "\"#{val}\"" if val.include?(' ')
      "#{k}=#{val}"
    end.join(', ')
  end

  def extract_text_content(event)
    content = event.dig('message', 'content') || []
    content
      .select { |b| b['type'] == 'text' }
      .map { |b| b['text'] }
      .join
  end

  def extract_tool_uses(event)
    content = event.dig('message', 'content') || []
    content.select { |b| b['type'] == 'tool_use' }
  end

  def extract_tool_results(event)
    content = event.dig('message', 'content') || []
    content.select { |b| b['type'] == 'tool_result' }
  end

  def extract_context_percentage(event)
    usage = event.dig('message', 'usage')
    return nil unless usage

    input = usage['input_tokens'] || 0
    cache_create = usage['cache_creation_input_tokens'] || 0
    cache_read = usage['cache_read_input_tokens'] || 0
    total_context = input + cache_create + cache_read

    return nil if total_context.zero?

    ((total_context.to_f / 200_000) * 100).round(1)
  end

  def with_temp_file(content)
    temp = Tempfile.new(['ralph-prompt', '.md'])
    temp.write(content)
    temp.close
    yield temp.path
  ensure
    temp&.unlink
  end

  def parse_progress(result)
    return { error: 'nil result', raw: nil } if result.nil?

    parsed = JSON.parse(result, symbolize_names: true)
    structured = parsed[:structured_output]

    if structured.nil?
      return { error: 'no structured_output', raw: result[0, 500] }
    end

    progress = structured[:progress]
    if progress.nil?
      return { error: 'no progress field', raw: result[0, 500] }
    end

    { progress: progress }
  rescue JSON::ParserError => e
    { error: "JSON parse error: #{e.message}", raw: result&.[](0, 500) }
  end

  def parse_summary(result)
    parsed = JSON.parse(result, symbolize_names: true)
    structured = parsed[:structured_output]
    return nil if structured.nil?

    structured[:summary]
  rescue JSON::ParserError
    nil
  end

  # ─────────────────────────────────────────────────────────────
  # State Management
  # ─────────────────────────────────────────────────────────────

  def record_progress(progress)
    entry = {
      iteration: @iteration,
      timestamp: Time.now.iso8601,
      progress: progress
    }
    File.open(@progress_file, 'a') { |f| f.puts(entry.to_json) }
  end

  def save_summary(summary)
    File.write(@summary_file, summary)

    # Update metadata with new coverage
    total = count_progress_entries
    new_coverage = total - SUMMARY_INTERVAL
    File.write(@summary_meta_file, JSON.generate({ 'covers_up_to' => new_coverage }))
  end

  def commit_iteration(progress)
    # Truncate progress for commit message
    short_progress = progress.to_s[0, 200]
    short_progress += '...' if progress.to_s.length > 200

    msg = <<~MSG
      ralph: iteration #{@iteration}

      #{short_progress}
    MSG

    system("jj commit -m #{msg.shellescape} >/dev/null 2>&1")
  end

  # ─────────────────────────────────────────────────────────────
  # Display
  # ─────────────────────────────────────────────────────────────

  def display_header
    duration_str = @duration_seconds == Float::INFINITY ? 'unlimited' : format_elapsed(@duration_seconds.to_i)
    unless @no_art
      ascii_file = File.join(SCRIPT_DIR, 'ralph.ascii')
      if File.exist?(ascii_file)
        print File.read(ascii_file).chomp
        puts '─' * 70
        puts
      end
    end
    puts "\e[1mRALPH v#{VERSION}\e[0m"
    puts
    puts "Braindead agentic loop. Just keep trying until it works."
    puts
    puts "\e[1mParams\e[0m"
    puts
    puts "Model: #{@model} | Reasoning: #{@reasoning} | Max Duration: #{duration_str}"
    puts
  end

  def display_goal
    goal_content = File.read(@goal_file)

    # Extract just the objective section
    objective = extract_objective(goal_content)

    puts "\e[1mGoal\e[0m"
    puts
    puts objective
    puts
  end

  def extract_objective(content)
    # Try to extract ## Objective section
    if content =~ /^## Objective\s*\n(.*?)(?=\n##|\z)/m
      return $1.strip
    end

    # Fallback: first 500 chars
    content[0, 500]
  end

  def display_iteration_header
    puts "\e[1mIteration #{@iteration}\e[0m"
    puts
  end

  def maybe_ralph_says
    return unless rand < 0.03  # 3% chance

    puts "\e[33mRalph:\e[0m #{RALPH_QUOTES.sample}"
    puts
  end

  def display_progress(progress)
    puts
    if progress == 'DONE'
      puts "\e[32m✓ DONE\e[0m"
      puts
    else
      # Word wrap and indent
      wrapped = word_wrap(progress, 66)
      wrapped.each_line do |line|
        puts "  #{line}"
      end
      puts
      puts '─' * 70
    end
  end

  def display_error(message)
    puts
    puts "\e[31m  ✗ #{message}\e[0m"
    puts
    puts '─' * 70
  end

  def display_summarizing
    puts "\e[33mSummarizing progress (every #{MAX_RECENT} iterations)...\e[0m"
    puts
    $stdout.flush
  end

  def display_summary
    elapsed = format_elapsed((Time.now - @start_time).to_i)
    puts
    puts "\e[1m" + '═' * 70 + "\e[0m"
    puts "\e[1m  COMPLETE\e[0m"
    puts "  Iterations: #{@iteration} | Elapsed: #{elapsed}"
    puts "\e[1m" + '═' * 70 + "\e[0m"
    puts
  end

  def word_wrap(text, width)
    text.gsub(/(.{1,#{width}})(\s+|$)/, "\\1\n").strip
  end

  # ─────────────────────────────────────────────────────────────
  # Notifications
  # ─────────────────────────────────────────────────────────────

  def notify_enabled?
    ENV['NTFY_TOPIC'] && ENV['NTFY_API_KEY']
  end

  def send_notification
    return unless notify_enabled?

    elapsed = format_elapsed((Time.now - @start_time).to_i)
    goal_name = File.basename(@goal_file, '.*').sub(/-goal$/, '')

    case @exit_reason
    when :done
      title = "Ralph: #{goal_name} complete"
      message = "Goal achieved in #{@iteration} iterations (#{elapsed})"
    when :timeout
      title = "Ralph: #{goal_name} timeout"
      message = "Time budget expired after #{@iteration} iterations (#{elapsed})"
    when :interrupted
      title = "Ralph: #{goal_name} interrupted"
      message = "Stopped at iteration #{@iteration} (#{elapsed})"
    else
      title = "Ralph: #{goal_name} exited"
      message = "Exited after #{@iteration} iterations (#{elapsed})"
    end

    notify_script = File.join(SCRIPT_DIR, '..', '..', 'scripts', 'notify')
    payload = { title: title, message: message }.to_json

    IO.popen(notify_script, 'r+') do |io|
      io.write(payload)
      io.close_write
      io.read  # consume output
    end
  rescue StandardError => e
    # Notification failure is non-fatal
    $stderr.puts "\e[33mNotification failed: #{e.message}\e[0m"
  end

  # ─────────────────────────────────────────────────────────────
  # Utilities
  # ─────────────────────────────────────────────────────────────

  def log(message)
    timestamp = Time.now.strftime('%H:%M:%S')
    puts "  \e[90m[#{timestamp}]\e[0m #{message}"
  end

  def fatal(message)
    $stderr.puts "\e[31mError: #{message}\e[0m"
    exit 1
  end

  def parse_duration(duration_str)
    return Float::INFINITY if duration_str.nil?

    value = duration_str.to_i
    unit = duration_str[-1]

    case unit
    when 'h' then value * 3600
    when 'm' then value * 60
    else value
    end
  end

  def format_elapsed(seconds)
    hours, remainder = seconds.divmod(3600)
    mins, secs = remainder.divmod(60)

    if hours > 0
      "#{hours}h #{mins}m #{secs}s"
    elsif mins > 0
      "#{mins}m #{secs}s"
    else
      "#{secs}s"
    end
  end

  def time_expired?
    return false if @duration_seconds == Float::INFINITY

    elapsed = Time.now - @start_time
    if elapsed >= @duration_seconds
      log "Time budget expired"
      true
    else
      false
    end
  end

  def calculate_thinking_budget(model, reasoning)
    max_budget = MAX_THINKING_BUDGET[model] || 32_000
    multiplier = REASONING_MULTIPLIERS[reasoning] || 0.25
    (max_budget * multiplier).to_i
  end

  # ─────────────────────────────────────────────────────────────
  # Spinner
  # ─────────────────────────────────────────────────────────────

  def start_spinner(message)
    return if @no_spinner

    @spinner_running = true
    start = Time.now

    @spinner_thread = Thread.new do
      idx = 0
      while @spinner_running
        elapsed = (Time.now - start).to_i
        mins, secs = elapsed.divmod(60)
        frame = SPINNER_FRAMES[idx % SPINNER_FRAMES.length]
        print "\r  #{frame} #{message} [#{format('%02d:%02d', mins, secs)}]"
        $stdout.flush
        idx += 1
        sleep 0.1
      end
      print "\r#{' ' * 60}\r"
      $stdout.flush
    end
  end

  def stop_spinner
    return if @no_spinner

    @spinner_running = false
    @spinner_thread&.join(1)
  end

  # ─────────────────────────────────────────────────────────────
  # Waiting Timer
  # ─────────────────────────────────────────────────────────────

  def start_waiting_timer(iteration_start)
    @waiting_timer_running = true
    @waiting_timer_displayed = false
    @last_output_time = Time.now

    @waiting_timer_thread = Thread.new do
      while @waiting_timer_running
        since_output = Time.now - @last_output_time
        if since_output >= 5.0
          @waiting_timer_displayed = true
          elapsed = format_elapsed(since_output.to_i)
          print "\r(#{elapsed})"
          $stdout.flush
        end
        sleep 0.1
      end
    end
  end

  def stop_waiting_timer
    @waiting_timer_running = false
    @waiting_timer_thread&.join(1)
    clear_waiting_timer
  end

  def reset_waiting_timer
    return unless @waiting_timer_running

    @last_output_time = Time.now
    clear_waiting_timer
  end

  def clear_waiting_timer
    return unless @waiting_timer_displayed

    print "\r#{' ' * 20}\r"
    $stdout.flush
    @waiting_timer_displayed = false
  end
end

# ─────────────────────────────────────────────────────────────
# CLI
# ─────────────────────────────────────────────────────────────

options = {
  model: 'sonnet',
  reasoning: 'low',
  no_spinner: true,
  no_art: false,
  continue: false
}

OptionParser.new do |opts|
  opts.banner = <<~BANNER
    Ralph - Braindead agentic loop. Just keep trying until it works.

    Usage: ralph --goal=FILE [--duration=4h] [options]
  BANNER

  opts.on('--goal=FILE', 'Goal markdown file (required)') do |f|
    options[:goal] = f
  end

  opts.on('--duration=DURATION', 'Time budget (e.g., 4h, 200m)') do |d|
    options[:duration] = d
  end

  opts.on('--model=MODEL', %w[haiku sonnet opus], 'Model: haiku, sonnet, opus (default: sonnet)') do |m|
    options[:model] = m
  end

  opts.on('--reasoning=LEVEL', %w[none low med high], 'Reasoning: none, low, med, high (default: low)') do |r|
    options[:reasoning] = r
  end

  opts.on('--spinner', 'Enable progress spinner (off by default)') do
    options[:no_spinner] = false
  end

  opts.on('--continue', 'Continue from existing progress') do
    options[:continue] = true
  end

  opts.on('--no-art', 'Suppress ASCII art in header') do
    options[:no_art] = true
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end

  opts.on('-v', '--version', 'Show version') do
    puts "ralph #{Ralph::VERSION}"
    exit
  end
end.parse!

if options[:goal].nil?
  $stderr.puts 'Error: --goal=FILE is required'
  $stderr.puts 'Usage: ralph --goal=FILE [--duration=4h] [options]'
  exit 1
end

ralph = Ralph.new(
  goal_file: options[:goal],
  duration: options[:duration],
  model: options[:model],
  reasoning: options[:reasoning],
  no_spinner: options[:no_spinner],
  no_art: options[:no_art],
  continue_run: options[:continue]
)

begin
  ralph.run
rescue Interrupt
  ralph.interrupt!
  puts "\n\nInterrupted"
  exit 130
end

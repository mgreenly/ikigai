#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'optparse'

# Run command and capture output, suppressing all output
def run_cmd(cmd, env: {}, chdir: nil)
  stdout_str = ''
  stderr_str = ''
  status = nil

  # Merge environment variables
  full_env = ENV.to_h.merge(env)

  # Change directory if specified
  orig_dir = Dir.pwd
  Dir.chdir(chdir) if chdir

  IO.popen(full_env, cmd, err: [:child, :out]) do |io|
    stdout_str = io.read
  end
  status = $?

  Dir.chdir(orig_dir) if chdir

  [status.exitstatus, stdout_str]
end

# Run make check-coverage and capture output
def run_make_coverage(project_root, threshold: nil)
  # Build command with optional threshold override
  cmd = ['make', 'check-coverage']
  cmd << "COVERAGE_THRESHOLD=#{threshold}" if threshold

  # Run make check-coverage once - it handles parallelization
  exit_code, output = run_cmd(cmd, chdir: project_root)

  [exit_code == 0, output]
end

# Parse output for ðŸ”´ lines (coverage failures)
# Returns array of file paths (strings)
def parse_coverage_failures(output)
  failures = []
  # Match detailed format: ðŸ”´ src/file.c: Lines=X%, Functions=Y%, Branches=Z%
  detailed_pattern = /^ðŸ”´\s+(.+?):\s+Lines=/
  # Match simple format: ðŸ”´ src/file.c
  simple_pattern = /^ðŸ”´\s+(.+\.c)\s*$/

  output.each_line do |line|
    if (match = detailed_pattern.match(line))
      failures << match[1]
    elsif (match = simple_pattern.match(line))
      failures << match[1]
    end
  end
  failures
end

# Parse coverage.info file to extract line, function, and branch coverage for a file
# Returns hash with :uncovered_lines, :covered_lines, :uncovered_branches, :uncovered_functions
def parse_coverage_info(coverage_info_path, source_file)
  abs_source = File.absolute_path(source_file)

  uncovered_lines = []
  covered_lines = []
  uncovered_branches = []  # Array of {line:, branch:}
  uncovered_functions = [] # Array of {line:, name:}
  current_functions = {}   # name -> line mapping
  in_target_file = false

  File.readlines(coverage_info_path).each do |line|
    line = line.strip

    # SF:<source file path>
    if line.start_with?('SF:')
      file_path = line[3..-1]
      in_target_file = (file_path == abs_source || file_path.end_with?(source_file))
      current_functions = {}
      next
    end

    next unless in_target_file

    # FN:<line>,<function name>
    if line.start_with?('FN:')
      parts = line[3..-1].split(',', 2)
      line_num = parts[0].to_i
      func_name = parts[1]
      current_functions[func_name] = line_num
      next
    end

    # FNDA:<execution count>,<function name>
    if line.start_with?('FNDA:')
      parts = line[5..-1].split(',', 2)
      exec_count = parts[0].to_i
      func_name = parts[1]
      if exec_count == 0 && current_functions[func_name]
        uncovered_functions << { line: current_functions[func_name], name: func_name }
      end
      next
    end

    # DA:<line number>,<execution count>
    if line.start_with?('DA:')
      parts = line[3..-1].split(',')
      line_num = parts[0].to_i
      exec_count = parts[1].to_i

      if exec_count == 0
        uncovered_lines << line_num
      else
        covered_lines << line_num
      end
      next
    end

    # BRDA:<line>,<block>,<branch>,<taken>
    # taken is "-" for not executable, or a number (0 = not taken)
    if line.start_with?('BRDA:')
      parts = line[5..-1].split(',')
      line_num = parts[0].to_i
      branch_id = parts[2].to_i
      taken = parts[3]
      if taken != '-' && taken.to_i == 0
        uncovered_branches << { line: line_num, branch: branch_id }
      end
      next
    end

    # end_of_record
    break if line == 'end_of_record'
  end

  {
    uncovered_lines: uncovered_lines,
    covered_lines: covered_lines,
    uncovered_branches: uncovered_branches,
    uncovered_functions: uncovered_functions
  }
end

# Resolve file path - handle both .c files and directories with main.c
def resolve_source_path(target_file)
  return target_file if File.exist?(target_file)

  # Try adding /main.c if it's a directory or .c that doesn't exist
  if File.directory?(target_file)
    main_c = File.join(target_file, 'main.c')
    return main_c if File.exist?(main_c)
  end

  # If path ends with .c but doesn't exist, try it as a directory with main.c
  if target_file.end_with?('.c')
    dir_path = target_file.sub(/\.c$/, '')
    main_c = File.join(dir_path, 'main.c')
    return main_c if File.exist?(main_c)
  end

  target_file
end

# Run make check-coverage for a single file
def run_make_coverage_file(project_root, file:, threshold: nil)
  cmd = ['make', 'check-coverage', "FILE=#{file}"]
  cmd << "COVERAGE_THRESHOLD=#{threshold}" if threshold

  exit_code, output = run_cmd(cmd, chdir: project_root)
  [exit_code == 0, output]
end

# Get all coverage gaps (lines, branches, functions) from coverage.info
def get_coverage_gaps(source_file, project_root)
  coverage_info = File.join(project_root, 'reports', 'coverage', 'coverage.info')
  return [] unless File.exist?(coverage_info)

  data = parse_coverage_info(coverage_info, source_file)
  return [] unless File.exist?(source_file)

  source_lines = File.readlines(source_file)
  items = []

  # Uncovered functions
  data[:uncovered_functions].each do |func|
    source_code = source_lines[func[:line] - 1]&.strip || ''
    items << "#{source_file}:#{func[:line]}: function never called: #{func[:name]}"
  end

  # Uncovered lines
  data[:uncovered_lines].each do |line_num|
    source_code = source_lines[line_num - 1]&.strip || ''
    items << "#{source_file}:#{line_num}: line not executed: #{source_code}"
  end

  # Uncovered branches - group by line
  branches_by_line = data[:uncovered_branches].group_by { |b| b[:line] }
  branches_by_line.each do |line_num, branches|
    source_code = source_lines[line_num - 1]&.strip || ''
    branch_ids = branches.map { |b| b[:branch] }.join(',')
    items << "#{source_file}:#{line_num}: branch not taken (#{branches.size} of #{branches.size * 2}): #{source_code}"
  end

  # Limit to first 100 items
  items.take(100)
end

# Main check function
def run_check_only(target_file: nil, threshold: nil)
  # Get project root
  script_dir = File.dirname(File.realpath(__FILE__))
  project_root = File.expand_path('../../..', script_dir)
  Dir.chdir(project_root)

  # Single file mode - run make check-coverage FILE=path with threshold
  if target_file
    resolved_path = resolve_source_path(target_file)
    success, output = run_make_coverage_file(project_root, file: resolved_path, threshold: threshold)

    if success
      puts JSON.generate(ok: true)
      return 0
    end

    # Get all coverage gaps (uncovered lines, branches, functions)
    items = get_coverage_gaps(resolved_path, project_root)
    items = ["#{resolved_path}: coverage below threshold (no details available)"] if items.empty?

    puts JSON.generate(ok: false, items: items)
    return 1
  end

  # Bulk mode - run make check-coverage and parse failures
  success, output = run_make_coverage(project_root, threshold: threshold)

  if success
    puts JSON.generate(ok: true)
    return 0
  end

  # Parse ðŸ”´ lines from output as coverage failures (array of file paths)
  failures = parse_coverage_failures(output)
  failures = ['unknown'] if failures.empty?

  puts JSON.generate(ok: false, items: failures)
  1
end

def main
  options = {}

  OptionParser.new do |opts|
    opts.banner = 'Usage: run.rb [options]'
    opts.on('--file FILE', 'Filter results to specific file') do |file|
      options[:file] = file
    end
    opts.on('--threshold PCT', Integer, 'Override coverage threshold percentage') do |pct|
      options[:threshold] = pct
    end
  end.parse!

  # Run check and exit with appropriate code
  exit run_check_only(target_file: options[:file], threshold: options[:threshold])
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end

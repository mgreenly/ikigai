#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'optparse'

# Run command and capture output, suppressing all output
def run_cmd(cmd, env: {}, chdir: nil)
  stdout_str = ''
  stderr_str = ''
  status = nil

  # Merge environment variables
  full_env = ENV.to_h.merge(env)

  # Change directory if specified
  orig_dir = Dir.pwd
  Dir.chdir(chdir) if chdir

  IO.popen(full_env, cmd, err: [:child, :out]) do |io|
    stdout_str = io.read
  end
  status = $?

  Dir.chdir(orig_dir) if chdir

  [status.exitstatus, stdout_str]
end

# Run make check-coverage and capture output
def run_make_coverage(project_root, threshold: nil)
  # Build command with optional threshold override
  cmd = ['make', 'check-coverage']
  cmd << "COVERAGE_THRESHOLD=#{threshold}" if threshold

  # Run make check-coverage once - it handles parallelization
  exit_code, output = run_cmd(cmd, chdir: project_root)

  [exit_code == 0, output]
end

# Parse output for ðŸ”´ lines (coverage failures)
# Returns array of hashes: {file:} or {file:, lines:, functions:, branches:}
def parse_coverage_failures(output)
  failures = []
  # Match detailed format: ðŸ”´ src/file.c: Lines=X%, Functions=Y%, Branches=Z%
  detailed_pattern = /^ðŸ”´\s+(.+?):\s+Lines=(\d+\.?\d*%),\s+Functions=(\d+\.?\d*%),\s+Branches=(\d+\.?\d*%)/
  # Match simple format: ðŸ”´ src/file.c
  simple_pattern = /^ðŸ”´\s+(.+\.c)\s*$/

  output.each_line do |line|
    if (match = detailed_pattern.match(line))
      failures << {
        file: match[1],
        lines: match[2],
        functions: match[3],
        branches: match[4]
      }
    elsif (match = simple_pattern.match(line))
      failures << { file: match[1] }
    end
  end
  failures
end

# Parse coverage.info file to extract line-by-line coverage for a file
def parse_coverage_info(coverage_info_path, source_file)
  abs_source = File.absolute_path(source_file)

  uncovered_lines = []
  covered_lines = []
  in_target_file = false

  File.readlines(coverage_info_path).each do |line|
    line = line.strip

    # SF:<source file path>
    if line.start_with?('SF:')
      file_path = line[3..-1]
      in_target_file = (file_path == abs_source || file_path.end_with?(source_file))
      next
    end

    next unless in_target_file

    # DA:<line number>,<execution count>
    if line.start_with?('DA:')
      parts = line[3..-1].split(',')
      line_num = parts[0].to_i
      exec_count = parts[1].to_i

      if exec_count == 0
        uncovered_lines << line_num
      else
        covered_lines << line_num
      end
    end

    # end_of_record
    break if line == 'end_of_record' && in_target_file
  end

  [uncovered_lines, covered_lines]
end

# Get detailed coverage for a specific source file from reports
def get_file_coverage_details(source_file, project_root)
  unless File.exist?(source_file)
    return { error: "#{source_file}: file not found" }
  end

  # Use the coverage.info file generated by make check-coverage
  coverage_info = File.join(project_root, 'reports', 'coverage', 'coverage.info')
  unless File.exist?(coverage_info)
    return { error: "Coverage data not found. Run 'make check-coverage' first." }
  end

  # Parse coverage.info to get line-by-line coverage data
  uncovered_lines, covered_lines = parse_coverage_info(coverage_info, source_file)

  if uncovered_lines.empty? && covered_lines.empty?
    return { error: "No coverage data found for #{source_file}. The file may not be tested." }
  end

  # Read the source file to get actual source code for uncovered lines
  uncovered_with_source = []
  if File.exist?(source_file)
    source_lines = File.readlines(source_file)
    uncovered_lines.each do |line_num|
      source_code = source_lines[line_num - 1]&.strip || ''
      uncovered_with_source << { line: line_num, source: source_code }
    end
  end

  {
    uncovered: uncovered_with_source,
    covered_count: covered_lines.size,
    uncovered_count: uncovered_lines.size,
    total_lines: covered_lines.size + uncovered_lines.size,
    coverage_pct: covered_lines.size * 100.0 / (covered_lines.size + uncovered_lines.size)
  }
end

# Parse a .gcov file to extract uncovered lines
def parse_gcov_file(gcov_file, source_file)
  uncovered_lines = []
  covered_lines = []

  File.readlines(gcov_file).each do |line|
    # gcov format: execution_count:line_number:source_code
    # -: means not executable (comment, declaration, etc.)
    # #####: means not covered (line was executable but never executed)
    # =====: means exceptional (gcc internal, ignore)
    # number: means executed that many times
    match = line.match(/^\s*(-|#####|=====|[0-9]+):\s*(\d+):(.*)$/)
    next unless match

    execution = match[1].strip
    line_num = match[2].to_i
    source = match[3]

    if execution == '#####'
      uncovered_lines << { line: line_num, source: source }
    elsif execution != '-' && execution != '=====' && execution.match?(/^\d+$/)
      covered_lines << line_num
    end
  end

  {
    uncovered: uncovered_lines,
    covered_count: covered_lines.size,
    uncovered_count: uncovered_lines.size
  }
end

# Resolve file path - handle both .c files and directories with main.c
def resolve_source_path(target_file)
  return target_file if File.exist?(target_file)

  # Try adding /main.c if it's a directory or .c that doesn't exist
  if File.directory?(target_file)
    main_c = File.join(target_file, 'main.c')
    return main_c if File.exist?(main_c)
  end

  # If path ends with .c but doesn't exist, try it as a directory with main.c
  if target_file.end_with?('.c')
    dir_path = target_file.sub(/\.c$/, '')
    main_c = File.join(dir_path, 'main.c')
    return main_c if File.exist?(main_c)
  end

  target_file
end

# Main check function
def run_check_only(target_file: nil, threshold: nil)
  # Get project root
  script_dir = File.dirname(File.realpath(__FILE__))
  project_root = File.expand_path('../../..', script_dir)
  Dir.chdir(project_root)

  # If target_file is specified, return detailed coverage for that file
  # Skip running make check-coverage since we use existing data
  if target_file
    resolved_path = resolve_source_path(target_file)
    details = get_file_coverage_details(resolved_path, project_root)

    if details[:error]
      puts JSON.generate(ok: false, items: [details[:error]])
      return 1
    end

    if details[:uncovered_count] == 0
      puts JSON.generate(ok: true)
      return 0
    end

    # Format uncovered lines as items showing line number and source code
    # Limit to first 100 lines
    items = details[:uncovered].take(100).map { |line_info| "Line #{line_info[:line]}: #{line_info[:source]}" }

    # If there are more than 100 uncovered lines, add a note about omitted lines
    if details[:uncovered].size > 100
      omitted = details[:uncovered].size - 100
      items << "... and #{omitted} more uncovered lines"
    end

    puts JSON.generate(ok: false, items: items)
    return 1
  end

  # Otherwise, run make check-coverage and check if it passes
  # The Makefile checks overall coverage (lines, functions, branches >= 90%)
  # which is the actual policy: "90% coverage for ENTIRE codebase"
  success, output = run_make_coverage(project_root, threshold: threshold)

  # Check if make check-coverage passed (exit code 0 = success)
  if success
    puts JSON.generate(ok: true)
    return 0
  end

  # Parse ðŸ”´ lines from output as coverage failures
  failures = parse_coverage_failures(output)
  if failures.empty?
    failures = [{ file: "unknown", lines: "0%", functions: "0%", branches: "0%" }]
  end

  puts JSON.generate(ok: false, items: failures)
  1
end

def main
  options = {}

  OptionParser.new do |opts|
    opts.banner = 'Usage: run.rb [options]'
    opts.on('--file FILE', 'Filter results to specific file') do |file|
      options[:file] = file
    end
    opts.on('--threshold PCT', Integer, 'Override coverage threshold percentage') do |pct|
      options[:threshold] = pct
    end
  end.parse!

  # Run check and exit with appropriate code
  exit run_check_only(target_file: options[:file], threshold: options[:threshold])
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end

#!/usr/bin/env ruby
# frozen_string_literal: true

#
# harness/prune/run - Automated dead code removal via Ralph
#
# 1. Runs check-prune to get candidates
# 2. Picks a random candidate
# 3. Generates a goal file
# 4. Runs Ralph to remove the function
#

require 'json'
require 'optparse'
require 'fileutils'

SCRIPT_DIR = File.dirname(File.realpath(__FILE__))
PROJECT_ROOT = File.expand_path('../../..', SCRIPT_DIR)
CHECK_SCRIPT = File.join(PROJECT_ROOT, '.claude/scripts/check-prune')
RALPH_SCRIPT = File.join(PROJECT_ROOT, '.claude/harness/ralph/run')
GOAL_TEMPLATE = File.join(SCRIPT_DIR, 'goal-template.md')

def log(msg)
  timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S')
  puts "#{timestamp} | prune      | #{msg}"
end

def run_check_prune
  log 'Running check-prune...'
  output = `#{CHECK_SCRIPT} 2>&1`
  exit_code = $?.exitstatus

  begin
    result = JSON.parse(output)
  rescue JSON::ParserError => e
    log "ERROR: Failed to parse check-prune output: #{e.message}"
    log "Output: #{output[0..500]}"
    return nil
  end

  if result['ok']
    log 'No dead code candidates found'
    return []
  end

  # Parse items: "function:file:line"
  candidates = result['items'].map do |item|
    parts = item.split(':')
    next nil if parts.length < 3

    {
      function: parts[0],
      file: parts[1],
      line: parts[2]
    }
  end.compact

  log "Found #{candidates.length} candidates"
  candidates
end

def generate_goal_file(candidate)
  function = candidate[:function]
  file = candidate[:file]
  line = candidate[:line]

  goal_filename = "pruning-#{function}-ralph-goal.md"
  goal_path = File.join(PROJECT_ROOT, goal_filename)

  template = File.read(GOAL_TEMPLATE)
  content = template
    .gsub('{{function}}', function)
    .gsub('{{file}}', file)
    .gsub('{{line}}', line)

  File.write(goal_path, content)
  log "Generated goal file: #{goal_filename}"

  goal_path
end

def run_ralph(goal_path, options)
  cmd = [RALPH_SCRIPT, "--goal=#{goal_path}"]
  cmd << "--duration=#{options[:duration]}" if options[:duration]
  cmd << "--model=#{options[:model]}" if options[:model]
  cmd << "--reasoning=#{options[:reasoning]}" if options[:reasoning]
  cmd << '--pull-request' if options[:pull_request]
  cmd << '--no-spinner' if options[:no_spinner]

  log "Running: #{cmd.join(' ')}"
  log ''

  # Exec replaces this process with ralph
  exec(*cmd)
end

def main
  options = {
    duration: '2h',
    model: 'sonnet',
    reasoning: 'med',
    pull_request: true,
    no_spinner: false
  }

  OptionParser.new do |opts|
    opts.banner = 'Usage: fix-prune [options]'

    opts.on('--duration DURATION', 'Time budget (default: 2h)') do |d|
      options[:duration] = d
    end

    opts.on('--model MODEL', 'Model: haiku, sonnet, opus (default: sonnet)') do |m|
      options[:model] = m
    end

    opts.on('--reasoning LEVEL', 'Reasoning: none, low, med, high (default: med)') do |r|
      options[:reasoning] = r
    end

    opts.on('--no-pr', 'Skip pull request creation') do
      options[:pull_request] = false
    end

    opts.on('--no-spinner', 'Disable spinner') do
      options[:no_spinner] = true
    end

    opts.on('--function NAME', 'Target specific function instead of random') do |f|
      options[:function] = f
    end
  end.parse!

  Dir.chdir(PROJECT_ROOT)

  # Get candidates
  candidates = run_check_prune
  exit 0 if candidates.nil? || candidates.empty?

  # Filter to specific function if requested
  if options[:function]
    candidates = candidates.select { |c| c[:function] == options[:function] }
    if candidates.empty?
      log "ERROR: Function '#{options[:function]}' not found in candidates"
      exit 1
    end
  end

  # Pick random candidate
  candidate = candidates.sample
  log "Selected: #{candidate[:function]} at #{candidate[:file]}:#{candidate[:line]}"

  # Generate goal file
  goal_path = generate_goal_file(candidate)

  # Run ralph (exec replaces this process)
  run_ralph(goal_path, options)
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end

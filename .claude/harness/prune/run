#!/usr/bin/env python3
import sys
sys.dont_write_bytecode = True
"""
harness/prune - Automated dead code removal loop

Runs scripts/dead-code.sh, removes functions one at a time with escalation,
commits on success, records false positives, continues until all processed
or no progress is made.
"""

import argparse
import subprocess
import sys
import os
import json
import threading
import time
from datetime import datetime
from pathlib import Path

# Configuration
MAX_ATTEMPTS_PER_FUNCTION = 3

# Escalation ladder: (model, thinking_budget, display_name)
ESCALATION_LADDER = {
    1: ("claude-sonnet-4-20250514", "10000", "sonnet:think"),
    2: ("claude-opus-4-20250514", "10000", "opus:think"),
    3: ("claude-opus-4-20250514", "128000", "opus:ultrathink"),
}

SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent.parent.parent
FIX_PROMPT_TEMPLATE = SCRIPT_DIR / "fix.prompt.md"
FALSE_POSITIVES_FILE = PROJECT_ROOT / ".claude" / "data" / "dead-code-false-positives.txt"
DEFAULT_TIMEOUT = 600


class Spinner:
    """Threaded spinner for long-running operations."""

    FRAMES = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]

    def __init__(self, message: str = ""):
        self.message = message
        self.running = False
        self.thread: threading.Thread | None = None
        self.start_time: float = 0

    def _spin(self) -> None:
        idx = 0
        while self.running:
            elapsed = int(time.time() - self.start_time)
            mins, secs = divmod(elapsed, 60)
            frame = self.FRAMES[idx % len(self.FRAMES)]
            sys.stdout.write(f"\r{frame} {self.message} [{mins:02d}:{secs:02d}]")
            sys.stdout.flush()
            idx += 1
            time.sleep(0.1)
        sys.stdout.write("\r" + " " * 60 + "\r")
        sys.stdout.flush()

    def start(self) -> None:
        self.running = True
        self.start_time = time.time()
        self.thread = threading.Thread(target=self._spin, daemon=True)
        self.thread.start()

    def stop(self) -> None:
        self.running = False
        if self.thread:
            self.thread.join(timeout=1)


def log(msg: str) -> None:
    """Print timestamped log message."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"{timestamp} | {'prune':10} | {msg}", flush=True)


def format_elapsed(seconds: float) -> str:
    """Format elapsed seconds as human-readable string."""
    hours, remainder = divmod(int(seconds), 3600)
    mins, secs = divmod(remainder, 60)
    if hours > 0:
        return f"{hours}h {mins}m {secs}s"
    elif mins > 0:
        return f"{mins}m {secs}s"
    else:
        return f"{secs}s"


def run_cmd(cmd: list[str], capture: bool = True, cwd: Path | None = None) -> tuple[int, str, str]:
    """Run a command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        cmd,
        capture_output=capture,
        text=True,
        cwd=cwd or PROJECT_ROOT,
    )
    return result.returncode, result.stdout or "", result.stderr or ""


def git_is_clean() -> bool:
    """Check if git workspace is clean."""
    code, stdout, _ = run_cmd(["git", "status", "--porcelain"])
    return code == 0 and not stdout.strip()


def git_get_modified_files() -> set[str]:
    """Get set of currently modified/untracked files."""
    code, stdout, _ = run_cmd(["git", "status", "--porcelain"])
    files = set()
    for line in stdout.strip().split('\n'):
        if line.strip():
            parts = line[3:].split(' -> ')
            files.add(parts[-1])
    return files


def git_commit(function: str, file: str, model_name: str, attempt: int, files_before: set[str]) -> bool:
    """Commit only files that changed during fix attempt."""
    files_after = git_get_modified_files()
    new_changes = files_after - files_before

    if not new_changes:
        return False

    for f in new_changes:
        run_cmd(["git", "add", f])

    msg = f"refactor: remove dead code {function}\n\nharness/prune | {model_name} | attempt {attempt}"

    code, _, _ = run_cmd(["git", "commit", "-m", msg])
    return code == 0


def git_revert(files_before: set[str] | None = None) -> None:
    """Revert changes made during fix attempt."""
    if files_before is not None:
        files_after = git_get_modified_files()
        new_changes = files_after - files_before
        if new_changes:
            log("Reverting uncommitted changes...")
            for f in new_changes:
                run_cmd(["git", "checkout", f])
    else:
        code, stdout, _ = run_cmd(["git", "status", "--porcelain"])
        if stdout.strip():
            log("Reverting uncommitted changes...")
            run_cmd(["git", "checkout", "."])
            run_cmd(["git", "clean", "-fd"])


def get_dead_code_candidates() -> list[dict]:
    """
    Run scripts/dead-code.sh and parse output.
    Returns list of {function, file, line} dicts.
    """
    log("Running dead-code analysis...")
    spinner = Spinner("Analyzing dead code")
    spinner.start()
    code, stdout, stderr = run_cmd(["./scripts/dead-code.sh"])
    spinner.stop()

    if code != 0:
        log(f"ERROR: dead-code.sh failed: {stderr}")
        return []

    candidates = []
    for line in stdout.strip().split('\n'):
        line = line.strip()
        # Skip comments and empty lines
        if not line or line.startswith('#'):
            if "No orphaned functions" in line:
                return []
            continue

        # Format: function:file:line
        parts = line.split(':')
        if len(parts) >= 3:
            candidates.append({
                "function": parts[0],
                "file": parts[1],
                "line": parts[2],
            })

    return candidates


def load_prompt_template() -> str:
    """Load the fix prompt template."""
    if not FIX_PROMPT_TEMPLATE.exists():
        log(f"ERROR: Missing {FIX_PROMPT_TEMPLATE}")
        sys.exit(1)
    return FIX_PROMPT_TEMPLATE.read_text()


def build_prompt(candidate: dict) -> str:
    """Build the fix prompt from template."""
    template = load_prompt_template()

    prompt = template.replace("{{function}}", candidate["function"])
    prompt = prompt.replace("{{file}}", candidate["file"])
    prompt = template.replace("{{file}}", candidate["file"])
    prompt = prompt.replace("{{function}}", candidate["function"])
    prompt = prompt.replace("{{line}}", candidate["line"])

    return prompt


def invoke_claude(prompt: str, model: str, thinking_budget: str, model_name: str, timeout: int) -> tuple[bool, str]:
    """
    Invoke Claude CLI with the prompt via stdin.
    Returns (success, response).
    """
    import tempfile

    with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
        f.write(prompt)
        prompt_file = f.name

    spinner = Spinner(f"Waiting for {model_name}")
    try:
        cmd = f'cat "{prompt_file}" | claude -p - --model {model} --allowedTools "Read,Edit,Write,Bash,Glob,Grep" --output-format json --max-turns 20'
        env = os.environ.copy()
        env["MAX_THINKING_TOKENS"] = thinking_budget
        spinner.start()
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            cwd=PROJECT_ROOT,
            timeout=timeout,
            env=env,
        )
        spinner.stop()
        code = result.returncode
        stdout = result.stdout or ""
        stderr = result.stderr or ""
    except subprocess.TimeoutExpired:
        spinner.stop()
        return False, f"Timeout after {timeout} seconds"
    finally:
        Path(prompt_file).unlink(missing_ok=True)

    if code != 0:
        return False, stderr

    try:
        result = json.loads(stdout)
        return True, result.get("result", "")
    except json.JSONDecodeError:
        return True, stdout


def record_false_positive(function: str) -> None:
    """Record a false positive to the exclusion file."""
    FALSE_POSITIVES_FILE.parent.mkdir(parents=True, exist_ok=True)

    existing = set()
    if FALSE_POSITIVES_FILE.exists():
        existing = set(FALSE_POSITIVES_FILE.read_text().strip().split('\n'))

    if function not in existing:
        with open(FALSE_POSITIVES_FILE, 'a') as f:
            f.write(f"{function}\n")
        log(f"Recorded false positive: {function}")


def parse_response(response: str) -> tuple[bool, str]:
    """
    Parse sub-agent response for SUCCESS/SKIPPED status.
    Returns (success, reason).
    """
    # First, look for the ---RESULT--- delimiter
    if "---RESULT---" in response:
        # Get everything after the delimiter
        after_delimiter = response.split("---RESULT---")[-1].strip()
        for line in after_delimiter.split('\n'):
            line = line.strip()
            if line.startswith("SUCCESS:"):
                return True, line[8:].strip()
            if line.startswith("SKIPPED:"):
                return False, line[8:].strip()

    # Fallback: look for SUCCESS or SKIPPED at start of any line
    for line in response.split('\n'):
        line = line.strip()
        if line.startswith("SUCCESS:"):
            return True, line[8:].strip()
        if line.startswith("SKIPPED:"):
            return False, line[8:].strip()

    # Last resort: check if response contains these keywords anywhere
    if "SUCCESS" in response.upper():
        return True, "removed (inferred)"
    if "SKIPPED" in response.upper():
        return False, "unknown reason (inferred)"

    # No clear indicator - assume failure
    return False, "no clear status in response"


def try_remove_function(candidate: dict, timeout: int) -> tuple[bool, str]:
    """
    Attempt to remove a dead code function.
    Returns (success, reason).
    """
    function = candidate["function"]
    file = candidate["file"]

    files_before = git_get_modified_files()

    for attempt in range(1, MAX_ATTEMPTS_PER_FUNCTION + 1):
        model, thinking_budget, model_name = ESCALATION_LADDER[attempt]

        log(f"Trying {model_name} (attempt {attempt}/{MAX_ATTEMPTS_PER_FUNCTION})")

        prompt = build_prompt(candidate)
        invoke_success, response = invoke_claude(prompt, model, thinking_budget, model_name, timeout)

        if not invoke_success:
            log(f"{model_name} invocation FAILED: {response[:200]}")
            continue

        # Parse the sub-agent's response
        success, reason = parse_response(response)

        if success:
            log(f"{model_name} SUCCESS")
            git_commit(function, file, model_name, attempt, files_before)
            return True, reason

        # Check for false positive
        if "false positive" in reason.lower():
            log(f"{model_name} SKIPPED (false positive)")
            git_revert(files_before)
            record_false_positive(function)
            return False, "false positive"

        log(f"{model_name} SKIPPED: {reason}")
        # Revert before trying next escalation level
        git_revert(files_before)

    # Exhausted all attempts
    log(f"SKIPPED - exhausted {MAX_ATTEMPTS_PER_FUNCTION} attempts")
    git_revert(files_before)
    return False, "exhausted attempts"


def main() -> int:
    """Main entry point."""
    start_time = time.time()

    parser = argparse.ArgumentParser(description="Automated dead code removal loop")
    parser.add_argument("--dry-run", action="store_true",
                        help="Identify dead code without removing it")
    parser.add_argument("--time-out", type=int, default=DEFAULT_TIMEOUT,
                        help=f"Timeout in seconds for each LLM invocation (default: {DEFAULT_TIMEOUT})")
    args = parser.parse_args()

    opts = []
    if args.dry_run:
        opts.append("dry-run")
    if args.time_out != DEFAULT_TIMEOUT:
        opts.append(f"timeout={args.time_out}s")
    log("Starting" + (f" ({', '.join(opts)})" if opts else ""))
    os.chdir(PROJECT_ROOT)

    # Precondition: git must be clean
    if not git_is_clean():
        log("ERROR: Git workspace must be clean before pruning.")
        return 1

    # Get candidates
    candidates = get_dead_code_candidates()

    if not candidates:
        log("No dead code found.")
        log(f"Completed (elapsed: {format_elapsed(time.time() - start_time)})")
        return 0

    log(f"Found {len(candidates)} dead code candidates")

    # Dry-run: just list candidates and exit
    if args.dry_run:
        log("Dead code candidates:")
        for c in candidates:
            log(f"  - {c['function']} at {c['file']}:{c['line']}")
        log(f"Completed (elapsed: {format_elapsed(time.time() - start_time)})")
        return 0

    removed = 0
    skipped = []
    fix_times: list[float] = []

    for i, candidate in enumerate(candidates, 1):
        function = candidate["function"]
        file = candidate["file"]
        line = candidate["line"]

        log(f"[{i}/{len(candidates)}] {function} at {file}:{line}")

        fix_start = time.time()
        success, reason = try_remove_function(candidate, args.time_out)
        fix_elapsed = time.time() - fix_start
        fix_times.append(fix_elapsed)

        if success:
            removed += 1
        else:
            skipped.append(f"{function} - {reason}")

        avg_time = sum(fix_times) / len(fix_times)
        remaining = len(candidates) - i
        eta = avg_time * remaining
        log(f"elapsed: {format_elapsed(fix_elapsed)} | ETA: {format_elapsed(eta)}")

    # Summary
    log("")
    log("/prune complete")
    log("")
    log(f"Removed: {removed}")
    log(f"Skipped: {len(skipped)}")

    if skipped:
        log("")
        log("Skipped functions:")
        for s in skipped:
            log(f"  - {s}")

    log(f"Completed (elapsed: {format_elapsed(time.time() - start_time)})")

    return 0 if removed > 0 or len(skipped) == 0 else 1


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(130)

#!/bin/bash
# harness/quality - Run all quality checks in fix-point loop
#
# Runs: compile → filesize → check → complexity → sanitize → tsan → valgrind → helgrind → coverage
#
# If any step makes commits, restarts from the beginning.
# Stops on first failure.
#
# Usage: ./run [--dry-run]
#   --dry-run: Pass to all sub-tasks to identify issues without fixing

START_TIME=$SECONDS

log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    printf '%s | %-10s | %s\n' "$timestamp" "quality" "$1"
}

# Run a command and exit with error message if it fails
# Usage: run_cmd "description" command [args...]
run_cmd() {
    local desc="$1"
    shift
    local output exit_code

    output=$("$@" 2>&1)
    exit_code=$?

    if [ $exit_code -ne 0 ]; then
        log "FATAL: $desc failed (exit $exit_code)"
        log "Command: $*"
        if [ -n "$output" ]; then
            log "Output: $output"
        fi
        exit 1
    fi

    echo "$output"
}

format_elapsed() {
    local total=$1
    local hours=$((total / 3600))
    local mins=$(((total % 3600) / 60))
    local secs=$((total % 60))
    if [ $hours -gt 0 ]; then
        echo "${hours}h ${mins}m ${secs}s"
    elif [ $mins -gt 0 ]; then
        echo "${mins}m ${secs}s"
    else
        echo "${secs}s"
    fi
}

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0")")" && pwd)"
HARNESS_DIR="$(dirname "$SCRIPT_DIR")"

# Verify clean workspace before starting
dirty=$(jj diff --summary 2>&1) || {
    log "FATAL: jj diff --summary failed"
    log "Output: $dirty"
    exit 1
}
if [ -n "$dirty" ]; then
    log "ERROR: Working copy is not clean. Commit changes before running quality checks."
    jj status
    exit 1
fi

# Pass all arguments to sub-tasks
ARGS="$@"

# Check if prune ran recently (look for prune commits in recent history)
check_prune_ran() {
    # Check last 10 commits for prune messages
    jj log -r 'ancestors(@, 10)' --no-graph -T 'description' 2>/dev/null | grep -q "harness/prune"
}

# Set AFTER_PRUNE for coverage if prune ran
if check_prune_ran; then
    export AFTER_PRUNE=1
    log "Detected recent prune commits - coverage will be aware"
fi

STEPS=(
    "compile"
    "filesize"
    "check"
    "complexity"
    "sanitize"
    "tsan"
    "valgrind"
    "helgrind"
    "coverage"
)

run_step() {
    local step="$1"
    local head_before head_after step_exit

    head_before=$(run_cmd "jj log (before $step)" jj log -r @ --no-graph -T 'commit_id.short()')

    "$HARNESS_DIR/$step/run" $ARGS
    step_exit=$?

    head_after=$(run_cmd "jj log (after $step)" jj log -r @ --no-graph -T 'commit_id.short()')

    if [ "$head_before" != "$head_after" ]; then
        return 1  # commits made, signal restart
    fi

    if [ $step_exit -ne 0 ]; then
        return 2  # step failed with no commits, unrecoverable
    fi

    return 0  # passed, continue
}

pass=1
while true; do
    log "Quality pass $pass"
    restart=false

    for step in "${STEPS[@]}"; do
        run_step "$step"
        result=$?

        if [ $result -eq 1 ]; then
            log "Step '$step' made commits, restarting from beginning"
            restart=true
            break
        elif [ $result -eq 2 ]; then
            log "Step '$step' failed with no progress, stopping"
            exit 1
        fi
    done

    if [ "$restart" = false ]; then
        log "All quality checks passed (elapsed: $(format_elapsed $((SECONDS - START_TIME))))"
        break
    fi

    ((pass++))
done

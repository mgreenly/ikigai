#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'optparse'
require 'time'

# Ralph: Iterative requirement completion harness
class Ralph
  # Quick checks after each requirement (harness names)
  QUICK_CHECKS = %w[
    compile
    filesize
    check
  ].freeze

  # Full checks at end of run (harness names)
  FULL_CHECKS = %w[
    compile
    filesize
    check
    complexity
    sanitize
    tsan
    valgrind
    helgrind
    coverage
  ].freeze

  SPINNER_FRAMES = %w[⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏].freeze

  RALPH_QUOTES = [
    "Me fail English? That's unpossible!",
    "I choo-choo-choose you!",
    "Hi, Super Nintendo Chalmers!",
    "I'm in danger!",
    "My cat's breath smells like cat food.",
    "I bent my Wookie.",
    "I ate the blue ones... they taste like burning.",
    "He told me to burn things.",
    "When I grow up I wanna be a principal or a caterpillar.",
    "Go banana!"
  ].freeze

  SELECT_OUTPUT_SCHEMA = '{"type":"object","properties":{"id":{"anyOf":[{"type":"integer"},{"type":"string"}]}},"required":["id"]}'
  WORK_OUTPUT_SCHEMA = '{"type":"object","properties":{"success":{"type":"boolean"},"message":{"type":"string"}},"required":["success","message"]}'

  # Max thinking budget per model (tokens) - powers of 2
  MAX_THINKING_BUDGET = {
    'haiku' => 16_384,   # 2^14
    'sonnet' => 32_768,  # 2^15
    'opus' => 16_384     # 2^14
  }.freeze

  # Reasoning level multipliers (powers of 2)
  REASONING_MULTIPLIERS = {
    'none' => 0.0,
    'low' => 0.25,   # 1/4 = 2^(-2)
    'med' => 0.5,      # 1/2 = 2^(-1)
    'high' => 1.0
  }.freeze

  def initialize(duration:, requirements_file:, history_file:, model: 'sonnet',
                 reasoning: 'low', no_spinner: false, continue: false)
    @duration_seconds = parse_duration(duration)
    @requirements_file = requirements_file
    @history_file = history_file
    @model = model
    @reasoning = reasoning
    @thinking_budget = calculate_thinking_budget
    @start_time = Time.now
    @script_dir = File.dirname(File.realpath(__FILE__))
    @spinner_enabled = !no_spinner
    @continue = continue
    @spinner_thread = nil
    @spinner_running = false
  end

  def calculate_thinking_budget
    max_budget = MAX_THINKING_BUDGET[@model] || 32_000
    multiplier = REASONING_MULTIPLIERS[@reasoning] || (1.0 / 3.0)
    (max_budget * multiplier).to_i
  end

  def claude_flags
    "--model #{@model}"
  end

  def claude_env
    env = ""
    env += "MAX_THINKING_TOKENS=#{@thinking_budget} " if @thinking_budget.positive?
    env
  end

  def render_prompt(template_file, vars = {})
    require 'erb'
    template = File.read(template_file)
    ERB.new(template).result_with_hash(vars)
  end

  def load_implementor_skills
    skillset_file = '.claude/skillsets/implementor.json'
    skillset = JSON.parse(File.read(skillset_file))

    skillset['preload'].map do |skill_name|
      skill_file = ".claude/library/#{skill_name}/SKILL.md"
      content = File.read(skill_file)
      { name: skill_name, content: content }
    end
  end

  def load_docs(doc_refs)
    doc_refs.map do |doc|
      path = doc['path']
      start_line = doc['start']
      end_line = doc['end'] || (doc['count'] ? start_line + doc['count'] - 1 : nil)

      lines = File.readlines(path)
      if start_line && end_line
        content = lines[(start_line - 1)..(end_line - 1)].join
        { path: "#{path}:#{start_line}-#{end_line}", content: content }
      elsif start_line
        content = lines[(start_line - 1)..-1].join
        { path: "#{path}:#{start_line}-end", content: content }
      else
        { path: path, content: lines.join }
      end
    rescue Errno::ENOENT
      { path: path || doc.to_s, content: "[File not found]" }
    end
  end

  def with_temp_prompt(content)
    require 'tempfile'
    temp = Tempfile.new(['ralph-prompt', '.md'])
    temp.write(content)
    temp.close
    yield temp.path
  ensure
    temp&.unlink
  end

  def run
    duration_str = @duration_seconds == Float::INFINITY ? 'infinite' : format_elapsed(@duration_seconds.to_i)
    log "Starting (model: #{@model}, reasoning: #{@reasoning}, budget: #{@thinking_budget}, duration: #{duration_str})"
    ensure_files_exist
    truncate_history unless @continue

    loop do
      break if time_expired?
      break if all_requirements_done?

      maybe_ralph_says
      requirement_id = select_requirement
      break unless requirement_id

      work_on_requirement(requirement_id)
    end

    run_final_quality_checks if all_requirements_done?
    cleanup
    summary
  end

  private

  def log(message)
    timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S')
    puts "#{timestamp} | #{'ralph'.ljust(10)} | #{message}"
    $stdout.flush
  end

  def truncate_history
    File.write(@history_file, '')
  end

  def maybe_ralph_says
    return unless rand < 0.1  # 10% chance
    log RALPH_QUOTES.sample
  end

  def format_elapsed(seconds)
    hours, remainder = seconds.divmod(3600)
    mins, secs = remainder.divmod(60)

    if hours > 0
      "#{hours}h #{mins}m #{secs}s"
    elsif mins > 0
      "#{mins}m #{secs}s"
    else
      "#{secs}s"
    end
  end

  def start_spinner(message)
    return unless @spinner_enabled

    @spinner_running = true
    start = Time.now

    @spinner_thread = Thread.new do
      idx = 0
      while @spinner_running
        elapsed = (Time.now - start).to_i
        mins, secs = elapsed.divmod(60)
        frame = SPINNER_FRAMES[idx % SPINNER_FRAMES.length]
        print "\r#{frame} #{message} [#{format('%02d:%02d', mins, secs)}]"
        $stdout.flush
        idx += 1
        sleep 0.1
      end
      print "\r#{' ' * 80}\r"
      $stdout.flush
    end
  end

  def stop_spinner
    return unless @spinner_enabled

    @spinner_running = false
    @spinner_thread&.join(1)
  end

  def parse_duration(duration_str)
    return Float::INFINITY if duration_str.nil?

    value = duration_str.to_i
    unit = duration_str[-1]

    case unit
    when 'h' then value * 3600
    when 'm' then value * 60
    else value
    end
  end

  def ensure_files_exist
    File.write(@history_file, '') unless File.exist?(@history_file)

    unless File.exist?(@requirements_file)
      File.write(@requirements_file, JSON.pretty_generate({ requirements: [] }))
    end
  end

  def time_expired?
    return false if @duration_seconds == Float::INFINITY

    elapsed = Time.now - @start_time
    if elapsed >= @duration_seconds
      log "Time budget expired (#{format_elapsed(@duration_seconds.to_i)})"
      true
    else
      false
    end
  end

  def all_requirements_done?
    requirements = load_requirements
    requirements.all? { |req| req['status'] == 'done' }
  end

  def load_requirements
    JSON.parse(File.read(@requirements_file))['requirements']
  end

  def save_requirements(requirements)
    data = { requirements: requirements }
    File.write(@requirements_file, JSON.pretty_generate(data))
  end

  def select_requirement
    log 'Selecting next requirement...'

    # Gather pending requirements
    requirements = load_requirements
    pending = requirements.select { |r| r['status'] == 'pending' }
                          .map { |r| { id: r['id'], requirement: r['requirement'] } }

    # Get recent history
    history_lines = File.exist?(@history_file) ? File.readlines(@history_file).last(10) : []

    start_spinner 'Waiting for selection agent'

    template_file = "#{@script_dir}/select.md.erb"
    prompt_content = render_prompt(template_file, {
      pending: pending,
      history: history_lines.join
    })

    result = nil
    exit_code = nil

    with_temp_prompt(prompt_content) do |prompt_file|
      # Selector gets read-only tools plus StructuredOutput
      result = `#{claude_env} claude -p #{prompt_file} #{claude_flags} --tools "Read,Glob,Grep,StructuredOutput" --output-format json --json-schema '#{SELECT_OUTPUT_SCHEMA}' 2>/dev/null`
      exit_code = $?.exitstatus
    end

    stop_spinner

    if exit_code != 0
      log "Selection agent FAILED: #{result[0..200]}"
      record_attempt('selector', nil, { success: false, message: "Selection agent failed (exit_code=#{exit_code})" })
      return select_requirement  # retry
    end

    # DEBUG: log raw structured_output
    begin
      parsed = JSON.parse(result, symbolize_names: true)
      log "DEBUG structured_output: #{parsed[:structured_output].inspect}"
    rescue => e
      log "DEBUG parse error: #{e.message}"
    end

    requirement_id = parse_select_outcome(result)

    if requirement_id.nil?
      log "Selection agent returned unparseable output: #{result[0..200]}"
      record_attempt('selector', nil, { success: false, message: "Could not parse selector output" })
      return select_requirement  # retry
    end

    return nil if requirement_id == 'none'

    # Validate it's a real requirement
    unless valid_requirement_id?(requirement_id)
      log "Invalid selection: '#{requirement_id[0..40]}'"
      record_attempt(requirement_id, nil, { success: false, message: "Invalid requirement ID selected" })
      return select_requirement  # retry
    end

    log "Selected: #{requirement_id}"
    requirement_id
  end

  def valid_requirement_id?(requirement_id)
    requirements = load_requirements
    valid_ids = requirements.map { |r| r['id'].to_s }
    valid_ids.include?(requirement_id)
  end

  def work_on_requirement(requirement_id)
    log "Working on #{requirement_id}..."

    # Look up the requirement
    requirements = load_requirements
    requirement = requirements.find { |r| r['id'].to_s == requirement_id.to_s }
    requirement_text = requirement['requirement']
    docs = load_docs(requirement['docs'] || [])

    start_spinner 'Waiting for work agent'

    template_file = "#{@script_dir}/work.md.erb"
    prompt_content = render_prompt(template_file, {
      requirement_id: requirement_id,
      requirement_text: requirement_text,
      docs: docs,
      history_file: @history_file,
      skills: load_implementor_skills
    })

    result = nil
    exit_code = nil

    with_temp_prompt(prompt_content) do |prompt_file|
      # Worker needs file/code tools plus StructuredOutput for final response
      # Don't merge stderr - it may contain streaming progress
      result = `#{claude_env} claude -p #{prompt_file} #{claude_flags} --tools "Read,Write,Edit,Glob,Grep,Bash,TodoWrite,Task,StructuredOutput" --output-format json --json-schema '#{WORK_OUTPUT_SCHEMA}' 2>/dev/null`
      exit_code = $?.exitstatus
    end

    stop_spinner

    outcome = parse_work_outcome(result, exit_code)
    record_attempt(requirement_id, requirement_text, outcome)

    if outcome[:success]
      if commit_work(requirement_id, outcome[:message])
        run_quality_checks(requirement_id)
      else
        log "Skipping quality checks (no changes)"
      end
    else
      restore_changes
      log "FAILED: #{outcome[:message]}"
    end
  end

  def record_attempt(requirement_id, requirement_text, outcome)
    entry = {
      timestamp: Time.now.iso8601,
      requirement_id: requirement_id,
      requirement: requirement_text,
      success: outcome[:success],
      message: outcome[:message]
    }
    File.open(@history_file, 'a') { |f| f.puts(entry.to_json) }
    trim_history(20)
  end

  def trim_history(max_entries)
    lines = File.readlines(@history_file)
    return if lines.size <= max_entries

    File.write(@history_file, lines.last(max_entries).join)
  end

  def parse_select_outcome(result)
    parsed = JSON.parse(result, symbolize_names: true)
    structured = parsed[:structured_output]
    return nil if structured.nil?

    # structured_output is already the parsed object: {id: ...}
    id_value = structured[:id]
    return nil if id_value.nil?

    id_value.to_s
  rescue JSON::ParserError
    nil
  end

  def parse_work_outcome(result, exit_code)
    # Parse outer JSON from --output-format json
    parsed = JSON.parse(result, symbolize_names: true)

    # With --json-schema, structured_output contains the parsed object
    structured = parsed[:structured_output]
    if structured.nil?
      return { success: false, message: "Agent produced no structured output (exit_code=#{exit_code})" }
    end

    {
      success: structured[:success] == true,
      message: structured[:message] || 'No message provided'
    }
  rescue JSON::ParserError => e
    { success: false, message: "Could not parse agent output: #{e.message}" }
  end

  def commit_work(requirement_id, message)
    # Sanitize message for shell safety
    safe_message = message.to_s.gsub(/[^a-zA-Z0-9\s\-_.,:]/, '')
    msg = "#{requirement_id}: #{safe_message}"

    commit_cmd = <<~SH
      jj commit -m "$(cat <<'COMMITMSG'
      #{msg}

      harness/ralph1 | work agent
      COMMITMSG
      )"
    SH

    system(commit_cmd, out: File::NULL, err: File::NULL)

    if $?.exitstatus == 0
      log 'Committed changes'
      true
    else
      log 'No changes to commit'
      false
    end
  end

  def run_quality_checks(requirement_id)
    log 'Running quick quality checks...'
    run_checks(QUICK_CHECKS)
    mark_requirement_done(requirement_id)
  end

  def run_final_quality_checks
    log 'Running final quality checks...'
    run_checks(FULL_CHECKS)
  end

  PROCESS_LOG = '.claude/harness/ralph1/process.log'

  def run_checks(checks)
    loop do
      all_passed = true

      checks.each do |harness|
        log "  Running #{harness}..."
        start_spinner "Running #{harness}"

        success = system(".claude/harness/#{harness}/run --no-spinner 2>&1 | tee -a #{PROCESS_LOG} >/dev/null")
        stop_spinner

        unless success
          log "  #{harness} FAILED - retrying (see #{PROCESS_LOG})"
          all_passed = false
          break
        end

        commit_check(harness)
      end

      break if all_passed
    end
  end

  def commit_check(check_name)
    msg = "fix: #{check_name}\n\nharness/ralph1 | quality check"
    system("jj commit -m '#{msg}' >/dev/null 2>&1")
    # Ignore failures - might be no changes
  end

  def mark_requirement_done(requirement_id)
    requirements = load_requirements
    requirement = requirements.find { |r| r['id'].to_s == requirement_id.to_s }

    if requirement
      requirement['status'] = 'done'
      save_requirements(requirements)
      system("jj commit -m 'ralph: mark #{requirement_id} done' >/dev/null 2>&1")
      log "✓ #{requirement_id} COMPLETE"
    end
  end

  def restore_changes
    system('jj restore >/dev/null 2>&1')
  end

  def cleanup
    log 'Cleaning uncommitted changes...'
    restore_changes
  end

  def summary
    elapsed = Time.now - @start_time

    requirements = load_requirements
    done = requirements.count { |r| r['status'] == 'done' }
    total = requirements.count

    log "Completed #{done}/#{total} requirements (elapsed: #{format_elapsed(elapsed.to_i)})"
  end
end

# Parse command line arguments
options = { model: 'sonnet', reasoning: 'low', no_spinner: false }

OptionParser.new do |opts|
  opts.banner = 'Usage: run --requirements=reqs.json [--duration=4h] [--history=history.jsonl] [options]'

  opts.on('--duration=DURATION', 'Time budget (e.g., 4h, 200m)') do |d|
    options[:duration] = d
  end

  opts.on('--requirements=FILE', 'Requirements JSON file') do |f|
    options[:requirements] = f
  end

  opts.on('--history=FILE', 'History markdown file (default: .claude/harness/ralph1/history.jsonl)') do |f|
    options[:history] = f
  end

  opts.on('--model=MODEL', %w[haiku sonnet opus], 'Model: haiku, sonnet, opus (default: sonnet)') do |m|
    options[:model] = m
  end

  opts.on('--reasoning=LEVEL', %w[none low med high],
          'Reasoning: none, low, med, high (default: low)') do |r|
    options[:reasoning] = r
  end

  opts.on('--no-spinner', 'Disable progress spinner') do
    options[:no_spinner] = true
  end

  opts.on('--continue', 'Continue from existing history (don\'t truncate)') do
    options[:continue] = true
  end
end.parse!

# Validate required arguments
if options[:requirements].nil?
  puts 'Error: Missing required arguments'
  puts 'Usage: run --requirements=reqs.json [--duration=4h] [--history=history.jsonl] [options]'
  exit 1
end

# Default history file
options[:history] ||= File.join(File.dirname(File.realpath(__FILE__)), 'history.jsonl')

# Run Ralph
ralph = Ralph.new(
  duration: options[:duration],
  requirements_file: options[:requirements],
  history_file: options[:history],
  model: options[:model],
  reasoning: options[:reasoning],
  no_spinner: options[:no_spinner],
  continue: options[:continue]
)

begin
  ralph.run
rescue Interrupt
  puts "\nInterrupted"
  exit 130
end

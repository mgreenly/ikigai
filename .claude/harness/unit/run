#!/usr/bin/env python3
import sys
sys.dont_write_bytecode = True
"""
harness/unit - Run unit tests

Runs unit tests, optionally filtering to tests for a specific source file.
"""

import argparse
import subprocess
import sys
import os
import json
import xml.etree.ElementTree as ET
from pathlib import Path

SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent.parent.parent
REPORTS_DIR = PROJECT_ROOT / "reports" / "check"


def run_cmd(cmd: list[str], capture: bool = True, cwd: Path | None = None, timeout: int | None = None) -> tuple[int, str, str]:
    """Run a command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        cmd,
        capture_output=capture,
        text=True,
        cwd=cwd or PROJECT_ROOT,
        timeout=timeout,
    )
    return result.returncode, result.stdout or "", result.stderr or ""


def find_test_files_for_source(source_file: str) -> list[str]:
    """
    Find unit test files for a source file.
    Maps: src/foo.c -> tests/unit/foo*_test.c OR tests/unit/foo/*_test.c
          src/db/agent.c -> tests/unit/db/agent*_test.c OR tests/unit/db/agent/*_test.c
    """
    source_path = Path(source_file)

    # Remove src/ prefix and .c suffix
    if not str(source_path).startswith("src/"):
        return []

    relative = source_path.relative_to("src")
    stem = relative.stem  # filename without extension
    parent = relative.parent

    test_files = []

    # Strategy 1: Look in tests/unit/parent_dir/ for stem*_test.c files
    test_dir = PROJECT_ROOT / "tests" / "unit" / parent
    if test_dir.exists():
        for test_file in test_dir.glob(f"{stem}*_test.c"):
            test_files.append(str(test_file.relative_to(PROJECT_ROOT)))

    # Strategy 2: Look in tests/unit/parent_dir/stem/ for *_test.c files
    test_subdir = PROJECT_ROOT / "tests" / "unit" / parent / stem
    if test_subdir.exists():
        for test_file in test_subdir.glob("*_test.c"):
            test_files.append(str(test_file.relative_to(PROJECT_ROOT)))

    return sorted(test_files)


def run_unit_tests(test_files: list[str] | None = None) -> tuple[bool, str]:
    """Run unit tests and return (success, output)."""
    if test_files:
        # Run specific test files
        all_success = True
        combined_output = ""
        for test_file in test_files:
            test_name = Path(test_file).stem
            code, stdout, stderr = run_cmd(
                ["make", "-j1", "MAKE_JOBS=1", "check-unit", f"TEST={test_name}"],
                timeout=1800
            )
            combined_output += stdout + stderr
            if code != 0:
                all_success = False
        return all_success, combined_output
    else:
        # Run all unit tests
        code, stdout, stderr = run_cmd(["make", "-j1", "MAKE_JOBS=1", "check-unit"], timeout=1800)
        return code == 0, stdout + stderr


def parse_failures_from_xml(filter_files: list[str] | None = None) -> list[dict]:
    """
    Parse XML reports from reports/check/ to extract failing tests.
    If filter_files is provided, only return failures from those test files.
    Returns list of {file, function, line, message} dicts.
    """
    failures = []

    if not REPORTS_DIR.exists():
        return failures

    # Convert filter files to set of basenames for matching
    filter_basenames = None
    if filter_files:
        filter_basenames = {Path(f).stem for f in filter_files}

    ns = {"check": "http://check.sourceforge.net/ns"}

    for xml_file in (REPORTS_DIR / "unit").rglob("*.xml"):
        # Check if this XML file matches our filter
        if filter_basenames and xml_file.stem not in filter_basenames:
            continue

        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()

            for test in root.findall(".//check:test[@result='failure']", ns):
                path_elem = test.find("check:path", ns)
                fn_elem = test.find("check:fn", ns)
                id_elem = test.find("check:id", ns)
                msg_elem = test.find("check:message", ns)

                if path_elem is None or fn_elem is None or id_elem is None:
                    continue

                # fn format: "basic_test.c:156"
                fn_parts = fn_elem.text.split(":")
                filename = fn_parts[0]
                line = fn_parts[1] if len(fn_parts) > 1 else "1"

                # Build full file path
                file_path = f"{path_elem.text}/{filename}"

                failures.append({
                    "file": file_path,
                    "function": id_elem.text,
                    "line": line,
                    "message": msg_elem.text if msg_elem is not None else "test failure",
                })

        except ET.ParseError:
            continue

    failures.sort(key=lambda f: (f["file"], f["function"]))
    return failures


def format_failure_item(failure: dict) -> str:
    """Format a failure as: test_file:line function_name: message"""
    return f"{failure['file']}:{failure['line']} {failure['function']}: {failure['message']}"


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Run unit tests")
    parser.add_argument("--file", type=str, default=None,
                        help="Source file to test (filters to relevant unit tests)")
    args = parser.parse_args()

    os.chdir(PROJECT_ROOT)

    test_files = None
    if args.file:
        target_file = args.file

        # Check if target file exists
        if not Path(target_file).exists():
            print(json.dumps({"ok": False, "items": [f"{target_file}: file not found"]}))
            return 1

        # Find test files for this source file
        test_files = find_test_files_for_source(target_file)

        if not test_files:
            print(json.dumps({"ok": False, "items": [f"{target_file}: no unit tests found"]}))
            return 1

    # Run tests
    success, output = run_unit_tests(test_files)

    if success:
        print(json.dumps({"ok": True}))
        return 0

    # Parse failures from XML
    failures = parse_failures_from_xml(test_files)

    if not failures:
        # Tests failed but no XML failures found - report generic error
        print(json.dumps({"ok": False, "items": ["Unit tests failed but no failures could be parsed"]}))
        return 1

    # Return failures as items
    items = [format_failure_item(f) for f in failures]
    print(json.dumps({"ok": False, "items": items}))
    return 1


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(130)

#!/usr/bin/env python3
import sys
sys.dont_write_bytecode = True
"""
harness/integration - Run integration tests

Runs integration tests, optionally filtering failures to a specific source file.
"""

import argparse
import subprocess
import sys
import os
import json
import re
from pathlib import Path

SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent.parent.parent


def run_cmd(cmd: list[str], capture: bool = True, cwd: Path | None = None, timeout: int | None = None) -> tuple[int, str, str]:
    """Run a command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        cmd,
        capture_output=capture,
        text=True,
        cwd=cwd or PROJECT_ROOT,
        timeout=timeout,
    )
    return result.returncode, result.stdout or "", result.stderr or ""


def run_integration_tests() -> tuple[bool, str]:
    """Run integration tests and return (success, output)."""
    code, stdout, stderr = run_cmd(["make", "-j1", "MAKE_JOBS=1", "check-integration"], timeout=1800)
    return code == 0, stdout + stderr


def parse_failures_from_output(output: str, filter_file: str | None = None) -> list[str]:
    """
    Parse test failures from make output.
    If filter_file is provided, only return failures that mention that file.
    """
    failures = []

    # Look for failed test indicators
    # Pattern: "ðŸ”´ build/tests/integration/something_test"
    failed_pattern = re.compile(r'ðŸ”´\s+(.+)')

    for line in output.split('\n'):
        match = failed_pattern.search(line)
        if match:
            test_path = match.group(1).strip()
            if filter_file:
                # Include this failure if the test name or path might relate to the file
                # This is a heuristic - we check if any part of the file path appears in test name
                file_parts = Path(filter_file).stem.split('_')
                test_name = Path(test_path).stem
                if any(part in test_name for part in file_parts if len(part) > 2):
                    failures.append(f"{test_path}: integration test failed")
            else:
                failures.append(f"{test_path}: integration test failed")

    # If we didn't find formatted failures, look for other failure patterns
    if not failures:
        # Pattern: test file path followed by failure indicator
        generic_fail_pattern = re.compile(r'(tests/integration/[^\s]+_test).*(?:FAIL|ERROR)', re.IGNORECASE)
        for line in output.split('\n'):
            match = generic_fail_pattern.search(line)
            if match:
                test_path = match.group(1)
                if filter_file:
                    file_parts = Path(filter_file).stem.split('_')
                    test_name = Path(test_path).stem
                    if any(part in test_name for part in file_parts if len(part) > 2):
                        failures.append(f"{test_path}: integration test failed")
                else:
                    failures.append(f"{test_path}: integration test failed")

    return failures


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Run integration tests")
    parser.add_argument("--file", type=str, default=None,
                        help="Source file to filter failures to (shows only relevant integration test failures)")
    args = parser.parse_args()

    os.chdir(PROJECT_ROOT)

    if args.file:
        target_file = args.file

        # Check if target file exists
        if not Path(target_file).exists():
            print(json.dumps({"ok": False, "items": [f"{target_file}: file not found"]}))
            return 1

    # Run integration tests (always runs all tests)
    success, output = run_integration_tests()

    if success:
        print(json.dumps({"ok": True}))
        return 0

    # Parse failures, optionally filtering to target file
    failures = parse_failures_from_output(output, args.file)

    if not failures and args.file:
        # Tests failed but none are related to target file
        print(json.dumps({"ok": True}))
        return 0

    if not failures:
        # Tests failed but couldn't parse failures
        print(json.dumps({"ok": False, "items": ["Integration tests failed but no failures could be parsed"]}))
        return 1

    # Return failures as items
    print(json.dumps({"ok": False, "items": failures}))
    return 1


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(130)

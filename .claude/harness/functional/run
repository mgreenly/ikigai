#!/usr/bin/env ruby
# frozen_string_literal: true

#
# harness/functional - Run functional tests
#
# Runs functional tests with parallelization, parses failures, outputs JSON summary.
# No fix functionality - check only.
#

require 'json'
require 'optparse'
require 'fileutils'
require 'pathname'

# Run command and capture output, suppressing all output
def run_cmd(cmd, env: {}, timeout: nil)
  stdout_str = ''
  status = nil

  # Merge environment variables
  full_env = ENV.to_h.merge(env)

  IO.popen(full_env, cmd, err: [:child, :out]) do |io|
    stdout_str = io.read
  end
  status = $?

  [status.exitstatus, stdout_str]
end

# Run functional tests
def run_functional_tests(file: nil)
  cmd = ['make', 'check-functional']
  cmd << "FILE=#{file}" if file

  exit_code, output = run_cmd(cmd, timeout: 1800)

  [exit_code == 0, output]
end

# Parse emoji markers to find failed tests (bulk mode)
# Pattern: ðŸ”´ build/tests/functional/something_test
def parse_failed_tests_from_output(output)
  failed_tests = []
  failed_pattern = /^ðŸ”´\s+(build\/tests\/\S+)$/

  output.each_line do |line|
    match = failed_pattern.match(line)
    if match
      test_path = match[1].strip
      failed_tests << test_path
    end
  end

  failed_tests.uniq
end

# Parse detailed failures from FILE= mode output
# Pattern: ðŸ”´ test_name:: message
def parse_detailed_failures_from_output(output)
  failures = []
  failed_pattern = /^ðŸ”´\s+(.+)$/

  output.each_line do |line|
    match = failed_pattern.match(line)
    if match
      failures << match[1].strip
    end
  end

  failures
end

def main
  options = {}

  OptionParser.new do |opts|
    opts.banner = 'Usage: run.rb [options]'
    opts.on('--file FILE', 'Source file to filter failures to') do |f|
      options[:file] = f
    end
  end.parse!

  # Change to project root (3 levels up from harness/functional/)
  script_dir = File.dirname(File.realpath(__FILE__))
  project_root = File.expand_path('../../..', script_dir)
  Dir.chdir(project_root)

  target_file = options[:file]

  if target_file
    # Check if target file exists
    unless File.exist?(target_file)
      puts JSON.generate(ok: false, items: ["#{target_file}: file not found"])
      exit 1
    end
  end

  # Run functional tests
  success, output = run_functional_tests(file: target_file)

  if success
    puts JSON.generate(ok: true)
    exit 0
  end

  if target_file
    # FILE= mode: parse detailed assertion failures
    failures = parse_detailed_failures_from_output(output)
  else
    # Bulk mode: parse test binary paths
    failures = parse_failed_tests_from_output(output)
  end

  if failures.empty?
    puts JSON.generate(ok: false, items: ['Functional tests failed but no failures could be parsed'])
    exit 1
  end

  # Return failures as items
  puts JSON.generate(ok: false, items: failures)
  exit 1
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end

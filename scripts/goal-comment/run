#!/usr/bin/env ruby
# frozen_string_literal: true

#
# scripts/goal-comment - Append a comment to a goal
#
# Usage: echo "comment text" | goal-comment <id>
#
# Output: JSON {"ok": true, "id": <comment-id>, "goal_id": <id>}
# Exit code: 0 on success, 1 on failure
#

require 'json'
require 'net/http'
require 'optparse'

RALPH_PLANS_HOST = ENV.fetch('RALPH_PLANS_HOST')
RALPH_PLANS_PORT = ENV.fetch('RALPH_PLANS_PORT')

def main
  OptionParser.new do |opts|
    opts.banner = <<~HELP
      Usage: echo "comment text" | goal-comment <id>

      Append a comment to a goal.

      Arguments:
        id    Goal ID (required)

      Input:
        Comment body is read from stdin.

      Output:
        JSON {"ok": true, "id": <comment-id>, "goal_id": <id>}

      Examples:
        echo "Analysis complete" | goal-comment 42
        cat report.md | goal-comment 42
    HELP
  end.parse!

  id = ARGV[0]&.to_i

  unless id && id > 0
    puts JSON.generate(ok: false, error: 'goal id is required')
    exit 1
  end

  body = $stdin.read.strip

  if body.empty?
    puts JSON.generate(ok: false, error: 'comment body cannot be empty')
    exit 1
  end

  uri = URI("http://#{RALPH_PLANS_HOST}:#{RALPH_PLANS_PORT}/goals/#{id}/comments")
  payload = { body: body }

  resp = Net::HTTP.post(uri, JSON.generate(payload), 'Content-Type' => 'application/json')
  result = JSON.parse(resp.body)

  puts JSON.generate(result)
  exit(result['ok'] ? 0 : 1)
rescue Errno::ECONNREFUSED
  puts JSON.generate(ok: false, error: "cannot connect to ralph-plans at #{RALPH_PLANS_HOST}:#{RALPH_PLANS_PORT}")
  exit 1
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end
